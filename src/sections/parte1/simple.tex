\documentclass[../main.tex]{subfiles}

\begin{document}


\section{Teoria dos Tipos Simples}

O cálculo $\lambda$ não-tipado possui alguns entraves ao tentar traduzir as funções matemáticas para seus termos. Um desses entraves é o fato que as funções matemáticas são mapeamentos entre dois conjuntos. Ou seja, essas funções possuem em sua definição os valores que vão esperar e os possíveis valores que vão retornar. A função soma $+:\mathbb{N} \to \mathbb{N}$ não pode aceitar os valores $true$ ou $false$. Porém, nas codificações do cálculo $\lambda$ descrito até então (Sem contar com os modelos), isso é possível. Por exemplo, é possível perceber que $false$ e $0$ são definidos pelo mesmo termo $\lambda xy . y$ (a definição de $0$ é $\alpha$-equivalente a essa), o que pode gerar confusão em sua aplicação.

Outro problema do Cálculo $\lambda$ não-tipado é o fato de poder existir recursões infinitas através de termos como $\Omega$ e $\Delta$. A tipagem dos termos faz com que esse tipo de fenômeno não ocorra. O que retira a Turing-completude, mas facilita outras coisas.

Para fazer essa descrição ser mais detalhada e evitar esse tipo de erro, Church introduziu tipos.

\subsection[Cálculo lambda simplesmente tipado (STLC)]{Cálculo $\lambda$ simplesmente tipado (ST$\lambda$C)}

\subsubsection{Tipos simples}

Uma forma simples de começar a tipagem dos $\lambda$-termos é considerando uma coleção de variáveis de tipos e uma forma de produzir mais tipos através dessa coleção, chamado de \emph{tipo funcional}

Seja $\mathbb{V}$ a coleção infinita de variáveis de tipos $\mathbb{V} = \{ \alpha, \beta, \gamma, \dots \}$, então:

\begin{definition}[A coleção de todos os tipos simples]
    A coleção dos tipos simples $\mathbb{T}$ é definida por:
    \begin{enumerate}
        \item (Variável de tipos) Se $\alpha \in \mathbb{V}$,  então $\alpha \in \mathbb{T}$
        \item (Tipo funcional) Se $\sigma, \tau \in \mathbb{T}$, então $(\sigma \to \tau) \in \mathbb{T}$.
    \end{enumerate}
    Na BNF, $\mathbb{T} = \mathbb{V} | \mathbb{T} \to \mathbb{T}$
\end{definition}

Os parenteses no tipo funcional são associativos à direita, ou seja o tipo $\alpha_1 \to \alpha_2 \to \alpha_3 \to \alpha_4$ é $(\alpha_1 \to (\alpha_2 \to (\alpha_3 \to \alpha_4)))$

Tipos simples arbitrários serão escritos com letras gregas minúsculas (Com excessão do $\lambda$) como $\sigma, \tau, \dots$, mas também podem ser escrito como letras latinas maiúsculas $A, B, \dots$ na literatura.


As variáveis de tipos são representações abstratas de tipos básicos como os números naturais $\mathbb{N}$ ou a coleção de todas as listas $\mathbb{L}$. Esses tipos serão explorados mais à frente. Já os tipos funcionais representam funções na matemática como por exemplo $\mathbb{N} \to \mathbb{N}$, o conjunto de funções que leva dos naturais para os naturais, ou $(\mathbb{N} \to \mathbb{Z}) \to \mathbb{Z} \to \mathbb{N}$, o conjunto de funções que recebem como entrada uma função que leva dos naturais aos inteiros e um inteiro e retorna um natural.

A sentença "O termo $M$ possui tipo $\sigma$" é escrita na forma $M : \sigma$. Todo termo possui um tipo único, logo se $x$ é um termo e $x : \sigma$ e $x : \tau$, então $\sigma \equiv \tau$.

Como os tipos foram introduzidos para lidar com o cálculo $\lambda$, eles devem ter regras para lidar com as operações de aplicação e abstração.

\begin{enumerate}
    \item (\emph{Aplicação}): No cálculo $\lambda$, sejam $M$ e $N$ termos, podemos fazer uma aplicação entre eles no estilo $MN$. Para entender como entram os tipos, é possível recordar de onde surge a intuição para a aplicação. Seja $f : \mathbb{N} \to \mathbb{N}$ a função $f(x) = x^2$, então, a aplicação de $3$ em $f$ é $f(3) = 3^2$. Nesse exemplo, omite-se o fato que para aplicar $3$ a $f$, $3$ tem que estar no domínio de $f$, ou seja, $3 \in \mathbb{N}$. No caso do cálculo $\lambda$, para aplicar $N$ em $M$, $M$ deve ter um tipo funcional, na forma $M : \sigma \to \tau$, e $N$ deve ter como tipo o primeiro tipo que aparece em $M$, ou seja $N : \sigma$. 
    \item (\emph{Abstração}): No cálculo $\lambda$, seja $M$ um termo, podemos escrever um termo $\lambda x . M$. A abstração "constroi" a função. Para a tipagem, seja $M : \tau$ e $x : \sigma$, então $\lambda x : \sigma . M : \sigma \to \tau$. É possível omitir o tipo da variável, escrevendo no estilo: $\lambda x . M : \sigma \to \tau$.
\end{enumerate}


Alguns exemplos:

\begin{enumerate}
    \item Seja $x$ do tipo $\sigma$, a função identidade é escrita na forma $\lambda x . x : \sigma \to \sigma$.
    \item O combinador $\text{\textbf{B}} \equiv \lambda xyz . x(yz)$ é tipado na forma $\text{\textbf{B}} : (\sigma \to \tau) \to (\rho \to \sigma) \to \rho \to \tau$.
    \item O combinador $\Delta \equiv \lambda x . xxx$ não possui tipagem. Isso ocorre pois, na aplicação $xx$, $x$ precisa ter como tipo $\sigma \to \tau$ e $\sigma$, mas como $x$ só pode ter um tipo, então $\sigma \to \tau \equiv \sigma$. O que não é possível em $\mathbb{T}$. Logo $\Delta$ (e $\Omega$ por motivos similares), não faz parte da teoria dos tipos simples.
\end{enumerate}

O último exemplo mostra que o teorema do ponto fixo não ocorre para todos os termos na teoria dos tipos simples e que não existe recursão infinita, fazendo com que a teoria dos tipos simples deixe de ser turing-completa.

\subsubsection{Abordagens para a tipagem}

Existem duas formas de tipar um $\lambda$-termo:

\begin{enumerate}
    \item (\emph{Tipagem à la Church} / \emph{Tipagem explícita} / \emph{Tipagem intrínseca} / \emph{Tipagem ontológica}) Nesse estilo de tipagem, só termos que possuem tipagem que satisfaz a construção de tipos interna à teoria são aceitos. Cada termo possui um tipo único.
    \item (\emph{Tipagem à la Curry} / \emph{Tipagem implícita} / \emph{Tipagem extrínseca} / \emph{Tipagem semântica}) Nesse estilo de tipagem, os termos são os mesmos do cálculo $\lambda$ não tipado e pode-se não definir o tipo do termo na sua introdução, mas deixá-lo aberto. Os tipos são buscados para o termo, por tentativa e erro.
\end{enumerate}


\textbf{Exemplos}

\begin{enumerate}
    \item (Tipagem intrínseca): Seja $x$ do tipo $\alpha \to \alpha$ e $y$ do tipo $(\alpha \to \alpha) \to \beta$, então $yx$ possui o tipo $\beta$. Se $z$ possuit tipo $\beta$ e $u$ possuir tipo $\gamma$, então $\lambda zu . z$ tem tipo $\beta \to \gamma \to \beta$ e a aplicação $(\lambda zu . z)(yx)$ é permitida pois o tipo $\beta$ de $yx$ equivale ao tipo $\beta$ que $\lambda zu . z$ recebe.
    \item (Tipagem extrínseca): Nessa tipagem, começa-se com o termo $M \equiv (\lambda zu . z)(yx)$ e tenta-se adivinhar qual seu tipo e o tipo de suas variáveis. É possível notar que $(\lambda zu . z)(yx)$ é uma aplicação, então $(\lambda zu . z)$ precisa ter um tipo $A \to B$, $yx$ precisa ter um tipo $A$ e $M$ terá um tipo $B$. Mas se $\lambda zu . z$ possui o tipo $A \to B$, então $\lambda u . z$ possui o tipo $B$ e, como o termo é uma abstração, $B$ precisa ser um tipo funcional, ou seja $B \equiv C \to D$. Logo $u : C$ e $z : D$. Já no caso de $yx : A$, $y$ precisa ter um tipo funcional para ser aplicado a $x$, logo sendo $x : E$, $y : E \to F$. Logo temos que $x : E, y : E \to A, z : A, u : C$. Só é necessário então substituir $A, C, E$ com tipos variáveis como $\alpha, \beta, \gamma$: $x : \alpha, y : \alpha \to \beta, z : \beta, u : \gamma$.
\end{enumerate}

No caso do exemplo 2, é possível escrever $x : \alpha, y : \alpha \to \beta, z : \beta, u : \gamma \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$. A lista à esquerda da $\vdash$ (lê-se catraca) é chamada de \emph{contexto}.

\subsubsection{Regras de derivação e Cálculo de sequêntes}

É necessário, na tipagem intrínseca, definir a coleção de todos os $\lambda$-termos tipados:

\begin{definition}[$\lambda$-termos pré-tipados]
    A coleção $\Lambda_{\mathbb{T}}$ de $\lambda$-termos pré-tipados é definida pela BNF: \\
    $\Lambda_{\mathbb{T}} = V | (\Lambda_{\mathbb{T}} \Lambda_{\mathbb{T}}) | (\lambda V :  \mathbb{T} . \Lambda_{\mathbb{T}})$
\end{definition}

Para expressar as tipagens dos $\lambda$-termos, é necessário desenvolver um conjunto de definições que ainda não foram mostradas:

\begin{definition}
    \hfil
    \begin{enumerate}
        \item Uma \emph{sentença} é $M : \sigma$, onde $M \in \Lambda_{\mathbb{T}}$ e $\sigma \in \mathbb{T}$. Nessa sentença, $M$ é chamado de \emph{sujeito} e $\sigma$ de \emph{tipo}
        \item  Uma \emph{declaração} é uma sentença com uma \emph{variável} como sujeito
        \item Um \emph{Contexto} é uma lista, possivelmente nula, de declarações com diferentes sujeitos
        \item Um \emph{Juizo} possui a forma $\Gamma \vdash M : \sigma$, onde $\Gamma$ é o contexto e $M : \sigma$ é uma sentença.
    \end{enumerate}
\end{definition}

Para estudar a tipagem, será utilizado um sistema de derivações trazido da lógica chamado de \emph{Cálculo de sequêntes}. O cálculo de sequêntes dá a possibilidade de gerar juizos de forma formal utilizando árvores de derivação no estilo: 

\begin{prooftree}
    \def\fCenter{\mbox{\ $\vdash$\ }}
    \AxiomC{$\text{premissa } 1$}

    \AxiomC{$\text{premissa } 2$}

    \AxiomC{$\dots$}

    \AxiomC{$\text{premissa } n$}

    \RightLabel{}
    \QuaternaryInfC{$\text{Conclusão}$}
\end{prooftree}


Acima da linha horizontal estão as premissas, que são cada uma um juizo, e abaixo da linha horizontal está a conclusão, que é em si um juizo também. A linha marca uma regra de derivação específica da teoria que se está trabalhando.

\begin{definition}[Regras de derivação para o ST$\lambda$C]
    \hfil
    \begin{itemize}
        \item (\emph{var}) $\Gamma \vdash x : \sigma$, dado que $x : \sigma \in \Gamma$.
        \item (\emph{appl}) \begin{prooftree}
            \def\fCenter{\mbox{\ $\vdash$\ }}
            \AxiomC{$\Gamma \vdash M : \sigma \to \tau$}
            \AxiomC{$\Gamma \vdash N : \sigma$}
            \RightLabel{appl}
            \BinaryInfC{$\Gamma \vdash MN : \tau$}
        \end{prooftree}
        \item (\emph{abst}) \begin{prooftree}
            \def\fCenter{\mbox{\ $\vdash$\ }}
            \AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}
            \RightLabel{abst}
            \UnaryInfC{$\Gamma \vdash \lambda x : \sigma . M : \sigma \to \tau$}
        \end{prooftree}
    \end{itemize}
\end{definition}

A regra \emph{(var)} não possui premissas e possui como conclusão o fato que dado um contexto $\Gamma$, se existe uma declaração em $\Gamma$, essa declaração é derivável através de $\Gamma$. Essa primeira regra é tratada como axioma em (Hindley, 1997), pois, assim como todo axioma, ela é derivável sem precisar de premissas. Na construção da árvore de dedução, essa regra está no topo como uma "raiz".

A regra \emph{(appl)} é equivalente no cálculo ao que foi feito antes. Essa regra também é chamada na literatura de $\to - elim$ ou $\to E$

A regra \emph{(abs)} é equivalente no cálculo à abstração e pode ser chamada na literatura de $\to - intro$ ou $\to I$.

\textbf{Exemplo:}

\begin{prooftree}
    \def\fCenter{\mbox{\ $\vdash$\ }}
    \AxiomC{(1) $y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{(2) $y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{(3) $ y : \alpha \to \beta, z : \alpha \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{(4) $ y : \alpha \to \beta \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{(5) $\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta$}
\end{prooftree}

Dada a derivação já montada, sua leitura pode ser feita de baixo para cima, feito levando em conta as premissas mais fundamentais até a conclusão final, de forma a adicionar informação aos juízos a cada passo, ou de cima para baixo, feito para entender qual caminho leva até o objetivo final.

\begin{enumerate}
    \item Os passos (1) e (2) usam a regra (\emph{var})
    \item O passo (3) usa a regra (\emph{app}) usando (1) e (2) como premissas
    \item O passo (4) usa a regra (\emph(abs)) com (3) como premissa
    \item O passo (5) usa a regra (\emph(abs)) com (4) como premissa
\end{enumerate}

As regras de derivação podem ser entendidas em outros contextos:

\emph{Matemática}: Seja $A \to B$ o conjunto de todas as funções de $A$ para $B$, então as regras se tornam:
\begin{enumerate}
    \item (\emph{aplicação funcional}) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{se $f$ é um membro de $A \to B$}
        \AxiomC{e se $c \in A$}
        \BinaryInfC{então $f(c) \in B$}
    \end{prooftree}
    \item (\emph{abstração funcional}) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{Se para $x \in A$ segue-se que $f(x) \in B$}
        \UnaryInfC{então $f$ é membro de $A \to B$}
    \end{prooftree}
\end{enumerate}

\emph{Lógica}: Seja $A \Rightarrow B$ "$A$ implica em $B$", então pode-se ler $A \to B$ como $A \Rightarrow B$. As regras se tornam:

\begin{enumerate}
    \item ($\Rightarrow - elim$) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{$A \to B$}
        \AxiomC{$A$}
        \BinaryInfC{$B$}
    \end{prooftree}
    \item ($\Rightarrow - intro$) \begin{prooftree}
        \alwaysNoLine
        \AxiomC{$A$}
        \UnaryInfC{$\vdots$}
        \alwaysSingleLine
        \UnaryInfC{$B$}
    \end{prooftree}
\end{enumerate}


A regra de eliminação é denominada de \emph{Modus Ponens}. Ambas as regras como estão escritas aí são parte das regras definidas na \emph{Dedução Natural}, um cálculo análogo ao cálculo de sequêntes (Toda árvore definida na dedução natural possui um equivalente no cálculo de sequêntes). Esse estilo de dedução natural é chamado de \emph{Dedução natural no estilo de Gentzen}, para diferenciá-lo da \emph{Dedução natural no estilo de Fitch} que é escrito como:

% \begin{equation*}
%     \begin{fitch}
%     \fh A A A & Assumption \\
%     \fa B B B & Main Proof Step \\
%     \fa C C C & Another Main Proof Step\\
%     \fa \fh D D D & New Assumption \\
%     \fa \fa E E E & Subproof Step \\
%     \fa \fa F F F & Another Subproof Step \\
%     \fa G G G & Main Proof Step \\
%     \fa H H H & Main Proof Step
%     \end{fitch}
%     \end{equation*}

\begin{definition}[$\lambda_\to$-termos legais]
    Um termo $M$ pré-tipado em $\lambda_\to$ é chamado \emph{legal} se existe um contexto $\Gamma$ e um tipo $\rho$ tal que $\Gamma \vdash M : \rho$.
\end{definition}

\subsubsection{Problemas resolvidos no STLC}

No geral, existem três tipos de problemas relacionados a julgamentos na teoria dos tipos:

\begin{enumerate}
    \item \emph{Bem-tipagem} (\emph{Well-typedness}) ou \emph{Tipabilidade}: esse problema surge da questão $$? \vdash \text{termo } : ?$$ Ou seja, saber se um termo é legal e, se não é, mostrar onde sua contrução falha. \\
    (1a) \emph{Atribuição de tipos}, que surge da questão: $$\text{contexto } \vdash \text{termo } : ?$$. Ou seja, dado um contexto e um termo, derive seu tipo.
    \item \emph{Checagem de tipos}, que surge da questão $$\text{contexto } \vdash^{?} \text{termo } : \text{tipo}$$. Ou seja, se é realmente verdadeiro que o termo possui o tipo no determinado contexto.
    \item \emph{Encontrar o termo}, que surge da questão: $$\text{contexto } \vdash ? : \text{tipo}$$. Um tipo particular desse problema é quando o contexto é vazio, ou seja $$\emptyset \vdash ? : \text{tipo}$$. 
\end{enumerate}

Todos esses problemas são \emph{decidíveis} em $\lambda_\to$. Ou seja, para cada um deles existe um \emph{algoritmo} (um conjunto de passos) que produz a resposta. Em outros sistemas, encontar um termo se torna \emph{indecidível}.

\subsubsection[Bem-tipagem no STLC]{Bem-tipagem em $\lambda_\to$}

Para exemplificar os passos necessários para resolver a bem-tipagem em $\lambda_\to$, será utilizado o exemplo descrito em 1.1.3, dessa vez passo a passo.

O objetivo é mostrar que o termo $M \equiv \lambda y : \alpha \to \beta . \lambda z : \alpha . yz$ é um termo legal. Logo, precisamos encontrar um contexto $\Gamma$ e um tipo $\rho$ tal que $\Gamma \vdash M : \rho$.

Primeiro, como não existem variáveis livres em $M$, o contexto inicial pode ser considerado vazio: $\Gamma = \emptyset$.

Inicialmente, o primeiro passo é descobrir qual a premissa, ou premissas, que gera o termo e a regra de dedução:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Como a primeira parte do termo é um $\lambda y$, a única regra possível inicialmente é a abstração:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Novamente, a única regra possível é a abstração:


\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Sobrou do lado direito da catraca o termo $yz$ que, vendo o contexto, é a aplicação de outros dois termos, logo a única regra possível é a aplicação:

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Como as premissas mais superiores são geradas de (\emph{var}), não há mais nenhum passo de premissas e a tipagem pode ser realizada de cima para baixo.

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}


\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta$}
\end{prooftree}

Se existisse algum problema no caso de encontrar variáveis com tipagem incongruente nas últimas premissas ou não ter mais nenhum passo, então o termo não seria bem-tipado.

% \begin{mathpar}
%     \inferrule
%         { aa \\ bb }
%         { cc }
%     \quad(\textsc { Yop })
% \end{mathpar}


\subsubsection[Checagem de tipos no STLC]{Checagem de tipos em $\lambda_\to$}

Seja o juizo $$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$$

é necessário construir uma árvore de inferências que demonstre que $\gamma \to \beta$ é o tipo correto do termo do lado direito.

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash^?(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

Usando a regra da aplicação, tem-se:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash yx : \text{ ? }$}
    \RightLabel{appl}
    \BinaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash^?(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

O lado direto se segue da regra da aplicação:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash x : \alpha \to \alpha$}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash y : (\alpha \to \alpha) \to \beta $}
    \RightLabel{appl}
    \BinaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash yx : \text{ ? }$}
\end{prooftree}

Usando essa subárvore, pode-se ver que $yx$ possui o tipo $yx : \beta$.

O lado esquerdo se segue da abstração:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \text{ ? }$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

abstraindo novamente:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \text{ ? }$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

Agora, é possível "descer" novamente "coletando" os tipos que foram deixados para trás:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

e

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$}
\end{prooftree}

Seja $\Gamma \equiv x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta$, a árvore completa fica:


\begin{prooftree}
    \AxiomC{$\Gamma, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$\Gamma, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$\Gamma \vdash \lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$}
    
    \AxiomC{$\Gamma \vdash x : \alpha \to \alpha$}
    \AxiomC{$\Gamma \vdash y : (\alpha \to \alpha) \to \beta $}
    \RightLabel{appl}
    \BinaryInfC{$\Gamma \vdash yx : \beta$}

    \RightLabel{appl}
    \BinaryInfC{$\Gamma \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

Dessa forma, é possível perceber que sim, a aplicação de $\lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$ com $yx : \beta$ possui o tipo $\gamma \to \beta$. 


\subsubsection[Encontrar termos no STLC]{Encontrar termos em $\lambda_\to$}

Seja o tipo $A \to B \to A$. A pergunta que fica é: é possível encontrar um termo para esse tipo? Essa pergunta é, vista do ponto da lógica, a mesma coisa que "é possível computar uma prova para essa proposição?" (Isso será visto mais adiante). Isso é a mesma coisa que: $\text{ ? } : A \to B \to A$. Pelas regras de inferência:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$\text{ ? } \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Supondo um termo $x : A$, pode-se escrever a árvore como:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : A \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

E supondo um outro termo $y : B$, pode-se escrever como:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Como já existe um termo de tipo $A$, pode-se substituir o termo desconhecido por $x$:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Usando a regra da abstração:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda y . x: B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}


Novamente:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda y . x: B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda xy . x : A \to B \to A$}
\end{prooftree}

\subsubsection[Propriedades gerais do STLC]{Propriedades gerais do ST$\lambda$C}

Ficaram faltando nas definições anteriores a explicação de algumas propriedades gerais da sintaxe do ST$\lambda$C.

Algumas propriedades sobre os contextos:

\begin{definition}[(Domínio, subcontexto, permutação, projeção)]
\hfill
\begin{enumerate}
    \item Se $\Gamma \equiv x_1 : \sigma_1, \dots, x_n : \sigma_n$, então o \emph{domínio} de $\Gamma$ ou $dom(\Gamma)$ é a lista $(x_1, \dots, x_n)$.
    \item Um contexto $\Gamma'$ é um \emph{subcontexto} do contexto $\Gamma$, ou $\Gamma' \subseteq \Gamma$ se todas as declarações que ocorrem em $\Gamma'$ também ocorrem em $\Gamma$ na mesma ordem.
    \item Um contexto $\Gamma'$ é uma \emph{permutação} do contexto $\Gamma$, ou $\Gamma' \subseteq \Gamma$ se todas as declarações que ocorrem em $\Gamma'$ também ocorrem em $\Gamma$ e vice-versa
    \item Se $\Gamma$ é um contexto e $\Phi$ o conjunto de variáveis, então a \emph{projeção} de $\Gamma$ em $\Phi$, ou $ \Gamma \upharpoonright \Phi$, é o subcontexto $\Gamma'$ de $\Gamma$ com $dom(\Gamma') = dom(\Gamma) \cap \Phi$
\end{enumerate}

Em uma lista, a ordem dos elementos importa.
    
\end{definition}

Exemplo: Seja $\Gamma \equiv y : \sigma, x_1 : \rho_1, x_2 : \rho_2, z : \tau, x_3 : \rho_3$, então:

\begin{enumerate}
    \item $dom(\emptyset) = ()$, onde $\emptyset$ é chamado de lista vazia;
    \item $dom(\Gamma) = (y, x_1, x_2, z, x_3)$
    \item $\emptyset \subseteq (x_1 : \rho_1, z : \tau) \subseteq \Gamma$ 
    \item $\Gamma \upharpoonright \{ z, u, x_1 \} = x_1 : \rho_1, z : \tau$
\end{enumerate}

Uma propriedade importante de $\lambda_{\rightarrow}$ é a seguinte:

\begin{lemma}(Lemma das variáveis livres)
    \newline
    Se $\Gamma \vdash L : \sigma$, então $FV(L) \subseteq dom(\Gamma)$.
\end{lemma}

Como consequência desse lemma, seja $x$ uma variável livre que ocorre em $L$, então $x$ possui um tipo, o qual é declarado no contexto $\Gamma$. Em um juizo, não é possível ocorrer confusão sobre o tipo de qualquer variável, pois todas as variáveis ligadas possuem seu tipo, antes da ligação $\lambda$.

Para provar esse lemma, é necessário usar uma técnica de prova chamada de \emph{indução estrutural}. Essa indução ocorre da seguinte forma:

Seja $\mathcal{P}$ a propriedade geral que se quer provar para uma expressão arbitrária $\mathcal{E}$, procede-se da seguinte forma:

\begin{itemize}
    \item Assumindo que $\mathcal{P}$ é verdadeira para toda expressão $\mathcal{E}'$ usada no construto $\mathcal{E}$ (\emph{Hipótese Indutiva}),
    \item e provando que $\mathcal{P}$ também é verdadeira para $\mathcal{E}$.
\end{itemize}

\emph{Prova do Lemma:} Seja $\mathcal{J} \equiv \Gamma \vdash L : \sigma$, e suponha que $\mathcal{J}$ é a conclusão final de uma derivação e assuma que o conteudo do Lemma vale para as premissas usadas para inferir a conclusão.

Pela definição das regras de inferência, existem três possibilidades de regra para conclusão: (\emph{var}), (\emph{appl}) e (\emph{abst}). Provando por casos:

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma \vdash x : \sigma$ se seguindo de $x : \sigma \in \Gamma$. O $L$ do lemma é o $x$ e precisamos provar que $FV(x) \subseteq dom(\Gamma)$. Mas isso é consequência direta de $x : \sigma \in \Gamma$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ deve ter a forma $\Gamma \vdash MN : \tau$ e precisa-se provar que $FV(MN) \in dom(\Gamma)$. Por indução, a regra já é válida para as premissas de (\emph{appl}), que são $\Gamma \vdash M : \sigma \to \tau$ e $\Gamma \vdash N : \sigma$. \\
    Assim, pode-se assumir que $FV(M) \subseteq dom(\Gamma)$ e $FV(N) \subseteq dom(\Gamma)$. Como $FV(MN) = FV(M) \cup FV(N)$, então $FV(MN) \subseteq dom(\Gamma)$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ deve ter a forma $\Gamma \vdash \lambda x : \sigma . M : \sigma \to \tau$ e precisa-se provar que $FV(\lambda x : \sigma . M) \in dom(\Gamma)$. Por indução, a regra já é válida para a premissa de (\emph{abst}), que é $\Gamma, x : \sigma \vdash M : \tau$. \\
    Assim, pode-se assumir que $FV(M) \subseteq dom(\Gamma) \cup \{ x \}$. Como $FV(\lambda x : \sigma . M) = FV(M) \backslash \{ x \}$, então $FV(M) \backslash \{ x \} \subseteq dom(\Gamma)$.
\end{enumerate}
\hfill Outras propriedades também podem ser provadas no mesmo estilo de indução:

\begin{lemma}(Afinamento, Condensação, Permutação)
    \begin{enumerate}
        \item (\emph{Afinamento}) Sejam $\Gamma'$ e $\Gamma''$ contextos tais que $\Gamma' \subseteq \Gamma''$. Se $\Gamma' \vdash M : \sigma$, então $\Gamma'' \vdash M : \sigma$
        \item (\emph{Condensação}) Se $\Gamma \vdash M : \sigma$, então também  $\Gamma \upharpoonright FV(M) \vdash M : \sigma$
        \item (\emph{Permutação}) Se $\Gamma \vdash M : \sigma$ e $\Gamma'$ é uma permutação de $\Gamma$, então $\Gamma'$ também é um contexto e $\Gamma' \vdash M : \sigma$.
    \end{enumerate}
\end{lemma}

explicação:

\begin{itemize}
    \item O "afinamento" de um contexto é uma extensão do contexto obtida ao adicionar declarações extras com novas variáveis. O lema anterior diz que: se $M$ é tem tipo $\sigma$ em um contexto $\Gamma'$, então $M$ também terá um tipo $\sigma$ em um contexto "mais fino" $\Gamma'$. Ou seja, a validade do tipo de $M$ não muda ao adicionar novas declarações ao contexto. 
    \item O lema da "condensação" diz que declarações $x : \rho$ podem ser retiradas de $\Gamma$ caso $x$ não ocorra livre em $M$. Ou seja, ele só deixa declarações relevantes à $M$.
    \item O lema da "permutação" diz que não importa o jeito que o contexto foi ordenado e também que declarações no contexto são mutualmente independentes, então não existe impedimento teórico para a permutação do contexto. (Isso não vai ser verdadeiro em todas as teorias)
\end{itemize}

\emph{Prova do (1)}: A prova será feita por indução no juizo $\mathcal{J} \equiv \Gamma' \vdash M : \sigma$, assumindo que $\Gamma' \subseteq \Gamma''$. Existem três casos para considerar correspondentes a cada regra de inferência:

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash x : \sigma$ se seguindo de $x : \sigma \in \Gamma'$. Mas se $\Gamma' \subseteq \Gamma''$, então $x : \sigma \in \Gamma''$. Desse modo, usando (\emph{var}) tem-se que $\Gamma'' \vdash x : \sigma$. 
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash MN : \tau$ e precisa-se provar que $\Gamma'' \vdash MN : \tau$. Por indução, o afinamento é válido em $\Gamma' \vdash M : \sigma \to \tau$ e $\Gamma' \vdash N : \tau$. Mas, sendo assim, tem-se que $M \in \Gamma'$ e $N \in \Gamma'$, logo: $M \in \Gamma''$ e $N \in \Gamma''$ e, usando a regra  (\emph{appl}) em cima de $\Gamma'' \vdash M : \sigma \to \tau$ e $\Gamma'' \vdash N : \tau$, tem-se que $\Gamma'' \vdash MN : \tau$. 
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ tem que ter a forma $\Gamma' \vdash \lambda x : \rho . L : \rho \to \tau$. Temos que provar que $\Gamma' \vdash \lambda x : \rho . L : \rho \to \tau$, assumindo que $x \not\in dom(\Gamma'')$. Por indução na regra, temos que o "afinamento" também é válido para $\Gamma', x : \rho \vdash L : \tau$. Mas, como $x \not\in dom(\Gamma'')$, então podemos criar o contexto $\Gamma'', x : \rho$. E é possível ver que $\Gamma', x : \rho \subseteq \Gamma'', x : \rho$. Dessa forma, se segue que: $\Gamma'', x : \rho \vdash L : \tau$ e, através da regra, $\Gamma'' \vdash \lambda x : \rho . L : \rho \to \tau$
\end{enumerate}

As provas das outras duas partes se seguem de forma similiar e são deixadas para o leitor como exercício.

Outro lema importante é o seguinte:

\begin{lemma}(Lema da Geração)
    \hfill
    \begin{enumerate}
        \item Se $\Gamma \vdash x : \sigma$, então $x : \sigma \in \Gamma$
        \item Se $\Gamma \vdash MN : \tau$, então existe um tipo $\sigma$ tal que $\Gamma \vdash M : \sigma \to \tau$ e $\Gamma \vdash N : \sigma $
        \item Se $\Gamma \vdash \lambda x : \sigma . M : \rho$, então existe um $\tau$ tal que $\Gamma, x : \sigma \vdash M : \tau$ e $\rho \equiv \sigma \to \tau$.
    \end{enumerate}
\end{lemma}

\emph{prova:} Pela inspeção das regras de inferência de $\lambda_{\rightarrow}$, é possível ver que não existe outra possibilidade a não ser as listadas no lema.

\begin{lemma}(Lema do subtermo)
    Se $M$ é legal, então todo subtermo de $M$ é legal.
\end{lemma}

Então, se existem $\Gamma_1$ e $\sigma_1$ tal que $\Gamma_1 \vdash M : \sigma_1$ e se $L$ é um subtermo de $M$, então existem $\Gamma_2$ e $\sigma_2$ tais que $\Gamma_2 \vdash L : \sigma_2$. Com essa descrição, é possível ver que a prova também se segue da indução nas regras.

\emph{prova}: Usando a indução e supondo $\Gamma \vdash x : \sigma$ como caso base, tem-se dois casos:

\begin{itemize}
    \item Se $M \equiv NL : \tau$, então tem-se que $\Gamma \vdash NL : \tau$, onde $N$ e $L$ são subtermos de $M$. Pelo lema da geração, existe um tipo $\sigma$ tal que $\Gamma \vdash N : \sigma \to \tau$ e $\Gamma \vdash L : \sigma $. Dessa forma, $N$ e $L$ são legais
    \item Se $M \equiv \lambda x . N : \rho$, então tem-se que $\Gamma \vdash  \lambda x . N : \rho$, onde $N$ é subtermo de $M$. Pelo lema da geração, existe um tipo $\tau$ tal que $\Gamma, x : \sigma \vdash M : \tau$ e $\rho \equiv \sigma \to \tau$. Dessa forma $M$ é legal e $\Gamma_2 \equiv \Gamma_1, x : \sigma$.
\end{itemize}

Uma propriedade importante da Teoria dos Tipos de Church é que cada termo possui um tipo único, que pode ser descrito no seguint lema:

\begin{lemma}(Unicidade dos tipos)
    Assuma que $\Gamma \vdash M : \sigma$ e $\Gamma \vdash M : \tau$, então $\sigma \equiv \tau$.
\end{lemma}

\emph{Prova}: Por indução na construção de $M$

\begin{theorem}(Decidabilidade)
    Em $\lambda_{\rightarrow}$, os seguintes problemas são decidíveis:
    \begin{enumerate}
        \item Boa-tipagem: $? \vdash term : ?$
        \item Checagem de tipos: $\text{contexto } \vdash^{?} \text{termo } : \text{tipo}$
        \item Encontrar termos: $\text{contexto } \vdash \text{?} : \text{tipo}$
    \end{enumerate}
\end{theorem}

\emph{Prova}: A prova pode ser encontrada em (Barendregt, 1992).

\subsubsection[Redução no STLC]{Redução no ST$\lambda$C}

Até agora, não havia sido definido o comportamento da $\beta$-redução no ST$\lambda$C. Para fazer isso, é necessário introduzir o seguinte lema:

\begin{lemma}(Lema da Substituição)
    Seja $\Gamma', x : \sigma, \Gamma'' \vdash M : \tau$ e $\Gamma' \vdash N : \sigma$, então $\Gamma', \Gamma'' \vdash M [x := N] : \tau$.
\end{lemma}

Esse lema diz que se em um termo legal $M$ for substituido todas as ocorrências da variável do contexto $x$ por um termo $N$ de mesmo tipo que $x$, então o resultado $M [x := N]$ possui o mesmo tipo que $M$.

\emph{prova}: Usando indução em cima do juizo $\mathcal{J} \equiv \Gamma', x : \sigma, \Gamma'' \vdash M : \tau$. 

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma', x : \sigma, \Gamma'' \vdash x : \sigma$. Se o contexto é bem formado, então $x : \sigma$ não está em $\Gamma''$ e $x \not\in FV(N)$. Com isso, pode-se inferir que $x [x:= N] : \sigma$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash MN : \tau$, pela regra de inferência, temos dois juizos $\mathcal{J}' \equiv \Gamma' \vdash M : \rho \to \tau$ e $\mathcal{J}'' \equiv \Gamma' x : \sigma \vdash N :\rho$ para os quais vale o lema, logo supondo $\Gamma' \vdash L : \sigma$, temos que: $\Gamma', \Gamma'' \vdash M [x := N] : \rho \to \tau$ e $\Gamma', \Gamma'' \vdash N [x := L] :\rho$. Usando a regra da aplicação, temos: $\Gamma', \Gamma'' \vdash (M [x := L])N(x := L) : \tau$ que é a mesma coisa que $\Gamma', \Gamma'' \vdash (MN)(x := L) : \tau$. $\qed$
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ tem que ter a forma $\Gamma' \vdash \lambda u : \rho . L : \rho \to \tau$. Logo existe um outro juizo $\mathcal{J}' \equiv \Gamma', x : \sigma, \Gamma'', u : \rho \vdash L : \tau$. Mas em $\mathcal{J}'$, $x : \sigma$ não pode ocorrer em $\Gamma'$, logo como $\Gamma' \vdash N : \sigma$, $x \not\in FV(N)$. Usando o lema, temos que $\Gamma', \Gamma'', u : \rho \vdash L [x := N] : \tau$. Usando a regra da abstração: $\Gamma', \Gamma'' \vdash \lambda u : \rho . (L [x := N]) : \rho \to \tau$, que é o mesmo que $\Gamma', \Gamma'' \vdash (\lambda u : \rho . L) [x := N] : \rho \to \tau$. $\qed$
\end{enumerate}

Tendo definido a substituição, pode-se definir a $\beta$-redução:

\begin{definition}($\beta$-redução de passo único para $\Lambda_{\mathbb{T}}$)
    \hfill
    \begin{enumerate}
        \item (Base) $(\lambda x : \sigma . M)N \rightarrow_{\beta} M[x := N]$
        \item (Compatibilidade) Como na definição 1.10
    \end{enumerate}
\end{definition}

Como os tipos não são importantes no processo de $\beta$-redução, o Teorema de Church-Rosser também se torna válido no $\lambda_{\rightarrow}$:

\begin{theorem}(Teorema de Church-Rosser)
    A propriedade de Church-Rosser também é válida para $\lambda_{\rightarrow}$
\end{theorem}

\begin{corollary}
    Suponha que $M =_{\beta} N$, então existe um $L$ tal que $M \twoheadrightarrow_{\beta} L$ e $N \twoheadrightarrow_{\beta} L$
\end{corollary}

\begin{lemma}(Redução do sujeito)
    Se $\Gamma \vdash L : \rho$ e se $L \twoheadrightarrow_{\beta} L'$, então $\Gamma \vdash L' : \rho$.
\end{lemma}

Esse lema final mostra que a $\beta$-redução não afeta a tipabilidade e não muda o tipo do termo afetado, logo o mesmo contexto inicial serve para inferir.

\emph{Prova: }

\begin{theorem}(Teorema da normalização forte)
    Todo termo legal $M$ é fortemente normalizável
\end{theorem}

Esse teorema garante que não existam termos que não são reduzíveis, ou seja, todo termo legal em $\lambda_{\rightarrow}$ possi uma forma normal e nem todo termo legal possui um ponto fixo. Isso faz com que o ST$\lambda$C não seja turing-completo.
Essa característica não é muito desejável na implementação de linguagens de programação, pois na vida real, é necessário implementar códigos que podem não terminar. Por esse motivo, é necessário formar extensões do cálculo para que ele funcione nesses casos. 

O fato do universo de funções legais possíveis ser reduzido bastante no ST$\lambda$C fez com que pesquisas em modelos partindo do Cálculo $\lambda$ não tipado fossem desenvolvidas. Esses modelos como trabalhados na subseção 1.2 possuem vantagens (e desvantagens) em relação à tipagem.

\subsection[Extensões ao STLC e as Teorias dos Tipos Simples]{Extensões ao ST$\lambda$C e as Teorias dos Tipos Simples}

Partindo do cálculo $\lambda$ não-tipado visto no capítulo anterior, sua tipagem natural é de fato a vista anteriormente usando somente tipos funcionais. Mas alguns comportamentos que os tipos deveriam ter acabam não sendo construidos ou sendo construidos de forma muito complicada e pouco natural. Alguns tipos adicionais são requeridos para construir uma teoria de tipos mais robusta.

A construção original da teoria dos tipos simples feita em \cite{church1940} já é, por si só, mais complexa que a teoria vista aqui. Dessa forma, esse seção se preocupa em extender o ST$\lambda$C visto até então para de fato a Teoria dos Tipos Simples.

Nessa seção serão introduzidos um tipo novo por vez, discutindo suas motivações, regras de inferência e exemplos de derivação. No final, eles serão reunidos para discutir a teoria dos tipos simples.


\subsubsection{Adendos sobre o tipo funcional}

Uma pergunta possível de se fazer é se a definição 3.1 pode ser reescrita tendo em mente as regras de inferência, e a resposta é sim. Para isso, é necessária a seguinte notação: seja $\alpha$ um tipo simples, a notação desse fato seria $\alpha \in \mathbb{T}$, agora pode-se usar a regra de$$\alpha \text{ Type}$$. Logo, é possível reformular a definição 3.1 da seguinte forma:

\begin{definition}
    Os tipos simples possuem as seguintes regras de derivação:
    \begin{enumerate}
        \item \AxiomC{}
              \RightLabel{para $\sigma \in \mathbb{V}$}
              \UnaryInfC{$\vdash \sigma \text{ Type} $}
              \DisplayProof
        \item 
        \AxiomC{$\vdash \sigma \text{ Type}$}
        \AxiomC{$\vdash \tau \text{ Type}$}
        \BinaryInfC{$\vdash \sigma \to \tau \text{ Type}$}
        \DisplayProof
    \end{enumerate}
\end{definition}

Outras formas de trabalhar com o conceito de tipos dessa forma serão introduzidos no próximo capítulo. Esse tipo de regra de inferência na teoria dos tipos simples serve para localizar de forma visual a formação dos tipos, por isso normalmente são chamadas de \emph{regras de formação}.

Uma outra forma de generalizar a construção feita anteriormente do tipo funcional é pensar as regras de inferência introduzidas anteriormente, a (\emph{abst}) e (\emph{appl}), como regras de introdução (\emph{intro}) e eliminação (\emph{elim}), respectivamente. Essas regras serão colocadas aqui:

\begin{center}
    \AxiomC{$\Gamma, x : \alpha \vdash M : \beta$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda x : \alpha . M : \alpha \to \beta$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash M : \alpha \to \beta$}
    \AxiomC{$\Gamma \vdash N : \alpha$}
    \LeftLabel{$\quad$($\to$-elim)}
    \BinaryInfC{$\Gamma \vdash MN : \beta$ }
    \DisplayProof
\end{center}


Outras duas regras de inferência importantes para a construção feita aqui são construidas em cima da $\beta$-redução e da $\eta$-redução. Para lembrar, a $\beta$-redução de um termo $(\lambda x . M)N$ é o termo $M[N/x]$ e a $\eta$-redução do termo $\lambda x . Mx$ é o termo $M$. Essas duas reduções podem ser escritas equacionalmente: seja $=$ uma relação de igualdade entre termos de um mesmo tipo, então  

\begin{center}
    \AxiomC{$\Gamma, x : \alpha \vdash M : \beta$}
    \AxiomC{$\Gamma \vdash N : \alpha$}
    \LeftLabel{$\beta$}
    \BinaryInfC{$\Gamma \vdash (\lambda x : \alpha . M)N = M[N/x] : \beta$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash M : \alpha \to \beta$}
    \LeftLabel{$\quad \eta$}
    \UnaryInfC{$\Gamma \vdash \lambda x : \alpha . Mx = M : \alpha \to \beta$}
    \DisplayProof
\end{center}


Nas exposições dos novos tipos nesse capítulo, os tipos serão introduzidos na ordem vista anteriormente sempre que possível: formação, introdução, eliminação, $\beta$-redução e $\eta$-redução.


\subsubsection{O tipo de produto e o tipo unitário ($\lambda 1_{\times}$)}

Uma primeira extensão do ST$\lambda$C é a teoria dos tipos simples possuindo os tipos funcionais, tipos de produto e o tipo unitário.

\emph{I. Tipo unitário}

O tipo unitário, também chamado de tipo vazio, é um tipo postulado, ou seja sua formação se comporta mais ou menos como na definição 3.8(1) vista anteriormente:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \mathbb{1} \text{ Type}$}
\end{prooftree}

Sua regra de introdução é a seguinte:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash () : \mathbb{1}$}
\end{prooftree}

O nome unitário é dado porque ele é somente habitado por um único termo denotado por $()$ ou por vezes $\langle \rangle$. Para postular que esse termo é único, é necessário ainda introduzir a seguinte regra:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \mathbb{1}$}
    \LeftLabel{$\eta$}
    \UnaryInfC{$\Gamma \vdash M = () : \mathbb{1}$}
\end{prooftree}

Sua regra de eliminação vai ser introduzida aqui da seguinte forma:

\begin{prooftree}
    \AxiomC{$ \vdash c : C$}
    \UnaryInfC{$ x : \mathbb{1} \vdash let () = x \text{ in } c : C$}
\end{prooftree}

Essa regra muda um pouco na teoria dos tipos dependentes mas isso será visto posteriormente.

A regra que falta é a da $\beta$-redução:

\begin{prooftree}
    \AxiomC{$ \vdash () : \mathbb{1}$}
    \LeftLabel{$\beta$}
    \UnaryInfC{$\vdash (let () = () \text{ in } c) = c : C$}
\end{prooftree}


\emph{II. Tipos de Produtos}

Os tipos de produtos são tipos que se comportam como pares ordenados. Sua notação de tipo é denotada pelo simbolo $\times$ como nos pares ordenados normalmente, sendo sua regra de formação:

\begin{prooftree}
    \AxiomC{$\vdash \sigma \text{ Type}$}
    \AxiomC{$\vdash \tau \text{ Type}$}
    \BinaryInfC{$\vdash \sigma \times \tau \text{ Type}$}
\end{prooftree}

Os elementos de um tipo $\sigma \times \tau$ são pares $\langle v, u\rangle$ formados por elementos $v : \sigma$ e $u : \tau$. Para eliminar esse tipo, é somente necessário pegar o primeiro elemento ou o segundo elemento do par e para isso são usados os operadores $\pi_1$ e $\pi_2$, respectivamente, chamados de \emph{projeções}.

Logo, as suas regras de introdução e eleminação são:

\begin{center}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \AxiomC{$\Gamma \vdash N : \tau$}
    \LeftLabel{($\times$-intro)}
    \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$ }
    \DisplayProof

    \AxiomC{$\Gamma \vdash P : \sigma \times \tau$}
    \LeftLabel{$\quad$($\times$-elim-$1$)}
    \UnaryInfC{$\Gamma \vdash \pi_1 P : \sigma$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash P : \sigma \times \tau$}
    \LeftLabel{$\quad$($\times$-elim-$2$)}
    \UnaryInfC{$\Gamma \vdash \pi_2 P : \tau$ }
    \DisplayProof
\end{center}

As suas regras de $\beta$-redução sãs as seguintes:

\begin{center}
    \AxiomC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$}
    \LeftLabel{$\beta$}
    \UnaryInfC{$\Gamma \vdash \pi_1 \langle M, N \rangle = M : \sigma$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$}
    \LeftLabel{$\quad\beta$}
    \UnaryInfC{$\Gamma \vdash \pi_2 \langle M, N \rangle = N : \tau$ }
    \DisplayProof
\end{center}

E a sua regra de $\eta$-redução é a seguinte:

\begin{prooftree}
    
    \AxiomC{$\Gamma \vdash t : \sigma \times \tau$}
    \LeftLabel{$\eta$}
    \UnaryInfC{$\Gamma \vdash \langle \pi_1 t, \pi_2 t \rangle = t : \sigma \times \tau$}
\end{prooftree}

As regras de substituição para o tipo de produtos são as seguintes:

$$(\pi_1 P)[L/v] \equiv \pi_1 (P[L/v])$$
$$(\pi_2 P)[L/v] \equiv \pi_2 (P[L/v])$$
$$\langle M, N \rangle [L/v] \equiv \langle M [L/v], N [L/v] \rangle$$


\emph{3. Exemplo}

Um exemplo básico do tipo de produto é a construção do seguinte tipo: $\sigma \times \tau \to \tau \times \sigma$. Ele significa basicamente que a operação de produto cartesiano é reflexiva e pode ser provado da seguinte forma:

\begin{prooftree}
    \AxiomC{$?$}
    \UnaryInfC{$\Gamma \vdash ? : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Usando a regra ($\to$-intro):

\begin{prooftree}
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash ? : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . ? : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Agora é necessário gerar um par onde o primeiro termo tem tipo $\tau$ e o segundo tem tipo $\sigma$.

\begin{prooftree}
    \AxiomC{$\Gamma, t : \sigma \times \tau \vdash \langle ? , ? \rangle : \tau \times \sigma$}
    \LeftLabel{($\times$-intro)}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash \langle ? , ? \rangle : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . \langle ? , ? \rangle : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Sabendo que o tipo de $\pi_1 t$ é $\sigma$ e o tipo de $\pi_2 t$ é $\tau$, sabe-se que $\langle \pi_2 t, \pi_1 t \rangle$ tem o tipo $\tau \times \sigma$ que é o tipo que se quer encontrar, logo:

\begin{prooftree}
    \AxiomC{$\Gamma, t : \sigma \times \tau \vdash \langle \pi_2 t ,\pi_1 t \rangle : \tau \times \sigma$}
    \LeftLabel{($\times$-intro)}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash \langle \pi_2, \pi_1 t \rangle : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . \langle  \pi_2, \pi_1 t \rangle : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Uma prova para o leitor é mostrar que $(\alpha \times \beta) \times \gamma \to \alpha \times (\beta \times \gamma)$ é habitado. 

Outro fato interessante que pode ser provado é o \emph{currying} que pode ser resumido no seguinte tipo: $((\alpha \times \beta) \to \gamma) \to (\alpha \to \beta \to \gamma)$. Isso mostra que caso a pessoa tenha uma função que pega um par e retorna um tipo, isso é o mesmo que uma função que pega cada elemento do par em um momento e retorna esse tipo.

A sua construção é feita da seguinte forma:

$\lambda f : ((\alpha \times \beta) \to \gamma) . \lambda x : \alpha . \lambda y : \beta . f\langle x, y \rangle$

\subsubsection{O tipo de produto disjunto e tipo vazio ($\lambda 1_{(\times, +)}$)}

\emph{I. O Tipo Vazio}

Enquanto o tipo unitário é caracterizado pela característica de só possuir um único termo, enquanto o tipo vazio é caracterizado de forma análoga por ser um tipo que não possui nenhum termo.

A sua regra de formação é a seguinte:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \emptyset \text{ Type}$}
\end{prooftree}

O tipo vazio, como seu próprio nome indica, não possui uma regra de introdução de termos.

\emph{II. O Tipo produto disjunto}

O tipo produto disjunto é uma formação na teoria dos tipos análoga à formação do produto disjunto na teoria dos conjuntos. Sua regra de formação é a seguinte:

\begin{prooftree}
    \AxiomC{$\vdash \sigma \text{ Type}$}
    \AxiomC{$\vdash \tau \text{ Type}$}
    \BinaryInfC{$\vdash \sigma + \tau \text{ Type}$}
\end{prooftree}

Sua regra de introdução, diferente do tipo de produto falado anteriormente, não depende da presença de dois termos, um para cada tipo no produto, mas somente de um dos dois termos:

\begin{center}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \LeftLabel{($+$-intro-1)}
    \UnaryInfC{$\Gamma \vdash \kappa M : \sigma + \tau$}
    \DisplayProof
    \AxiomC{$\Gamma \vdash N : \tau$}
    \LeftLabel{($+$-intro-2)}
    \UnaryInfC{$\Gamma \vdash \kappa' N : \sigma + \tau$}
    \DisplayProof
\end{center}

Normalmente o operador $\kappa$ é chamado de $inl$ enquanto o operador $\kappa'$ é chamado de $inr$ na teoria dos tipos dependentes, mas aqui está sendo usada a notação de \cite{jacobs1999}. $\kappa$ é denominado de \emph{coprojeção}

Sua regra de eliminação é a mais complexa introduzida aqui, sendo a seguinte:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash P : \sigma + \tau$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{($+$-elim)}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } P \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] : \rho$}
\end{prooftree}

A interpretação dessa regra é a seguinte: olhe para $P$, se $P$ está em $\sigma$ então faça $Q$ com $P$ sendo $x$, caso $P$ esteja em $\tau$, faça $R$ com $P$ como $y$.

Para o unpack, as regras de $\beta$-redução se seguem da interpretação da eliminação:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } \kappa M \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] = Q[M/x] : \rho$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash N : \tau$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } \kappa' N \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] = R[N/y] : \rho$}
\end{prooftree}

A regra de $\eta$ redução é a seguinte:


\begin{prooftree}
    \AxiomC{$\Gamma \vdash P : \sigma + \tau$}
    \AxiomC{$\Gamma, z : \sigma + \tau \vdash R : \rho$}
    \LeftLabel{$\eta$}
    \BinaryInfC{$\Gamma \vdash \text{unpack } P \text{ as } [\kappa x \text{ in } R[(\kappa x)/z], \kappa'y \text{ in } R[(\kappa' y)/z]] = R[P/z] : \rho$}
\end{prooftree}

O operador unpack também pode ser chamado de \emph{match}, por ter essa noção de casar as coprojeções de $P$ para dois casos diferentes.

\emph{III. Exemplo}

Uma prova interessante é a que os coprodutos são distributivos em relação à produtos, ou seja $((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$

Para isso, é necessário construir a seguinte árvore de prova:

\begin{prooftree}
    
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma \vdash ? : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

Usando a abstração:

\begin{prooftree}
    
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma, u : (\sigma \times \tau) + (\sigma \times \rho) \vdash ? : \sigma \times (\tau + \rho)$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda u : (\sigma \times \tau) + (\sigma \times \rho) . ? : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

Ao "abrir" $u$, tem-se duas possibilidades:

\begin{itemize}
    \item $u$ é do tipo $\sigma \times \tau$, ou seja $\pi_1 u = \sigma$ e $\pi_2 u = \tau$, com $pi_1 u$ tem-se a primeira parte do tipo objetivo, já $\tau + \rho$ é possível ser gerado por $\kappa (\pi_2 u)$
    \item $u$ é do tipo $\sigma \times \rho$, ou seja $\pi_1 u = \sigma$ e $\pi_2 u = \rho$, da mesma forma tem-se a primeira parte do tipo objetivo de cara, já $\tau + \rho$ é gerado por $\kappa' (\pi_2 u)$.
\end{itemize}

Logo o termo final é o seguinte:
$$ \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho)$$

Logo a árvore final é:


\begin{prooftree}
    \AxiomC{$\Gamma \vdash u : (\sigma \times \tau) + (\sigma \times \rho)$}
    \AxiomC{$\Gamma, x : (\sigma \times \tau)  \vdash  : \langle \pi_1 x, \kappa( \pi_2 x) \rangle : \sigma \times (\tau + \rho)$}
    \AxiomC{$\Gamma, y : (\sigma \times \rho) \vdash \langle \pi_1 y, \kappa'( \pi_2 y) \rangle : \sigma \times (\tau + \rho)$}
    \LeftLabel{($+$-elim)}
    \TrinaryInfC{$\Gamma, u : (\sigma \times \tau) + (\sigma \times \rho) \vdash \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho)$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda u : (\sigma \times \tau) + (\sigma \times \rho) . \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho) : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

O resto da dedução da árvore fica como exercício para o leitor.

\subsubsection{O Tipo dos Números Naturais}

Foi visto na parte do cálculo $\lambda$ não tipado a codificação dos números naturais utilizando o método da codificação de Church. Esse tipo de codificação é útil caso se queira trabalhar com uma versão reduzida da teoria dos tipos e possui propriedades interessantes que serão exploradas na parte do Sistema F no próximo capítulo. Porém, uma de suas desvantagens é que muitas vezes os cálculos podem demandar muito, principalmente se essa codificação for utilizada em linguagens de programação. Dessa forma, um jeito mais fácil de desenvolver os números naturais é postulando-os da mesma forma que foi feito anteriormente.

Primeiro, é necessário postular a existência de um tipo dos números naturais:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \mathbb{N} \text{ Type}$}
\end{prooftree}

A sua regra de introdução segue os axiomas de Peano sobre o número $0$ e a função sucessor $succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$ que leva um número $n$ ao seu sucessor $n + 1$. Na forma de regras de inferência:

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\vdash 0 : \mathbb{N}$}
    \DisplayProof
    \AxiomC{}
    \LeftLabel{$\qquad$}
    \UnaryInfC{$\vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    \DisplayProof
\end{center}

Essa forma de definir a função sucessor é encontrada em por exemplo \cite{rijke2022}. Uma outra forma de definir o sucessor é a vista em \cite{pfanning2009} como:


\begin{prooftree}
    \AxiomC{$\vdash n : \mathbb{N}$}
    \UnaryInfC{$\vdash S (n) : \mathbb{N}$}
\end{prooftree}

A regra de eliminação do tipo $\mathbb{N}$ é baseado no método da indução que diz o seguinte: Seja $\phi$ um predicado tal que

\begin{enumerate}[label=(\arabic*)]
    \item $\phi(0)$ é verdade, e
    \item para todo número natural $n$, se $\phi(n)$ é verdadeiro, então $\phi(S(n))$ também o é
\end{enumerate}

Logo $\phi(n)$ é verdadeiro para todo número natural $n$. 

Para a teoria dos tipos simples, o predicado $\phi$ se torna um tipo $P$ e sua regra de eliminação se torna:


\begin{prooftree}
    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{($\mathbb{N}$-elim)}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S) : \mathbb{N} \to P$}
\end{prooftree}

A interpretação dessa regra é a seguinte:

\begin{itemize}
    \item Premissa 1: Dado que de um termo $n : \mathbb{N}$ é possível derivar o tipo $P$
    \item Premissa 2: Dado que $P$ é válido para $0$, tendo como prova $p_0$
    \item Premissa 3: equivale à regra (2) para o predicado $\phi$ anterior
    \item Conclusão: o termo $ind_{\mathbb{N}}(p_0, p_S)$ é a função que pega as duas provas da indução e gera o tipo $P$.
\end{itemize}

Como sua regra de eliminação está relacionada ao conceito de indução, o tipo $\mathbb{N}$ é chamado de um \emph{tipo indutivo}. Não só $\mathbb{N}$ é um tipo, indutivo, mas também outros tipos como o tipo unitário e o tipo dos booleanos, que será visto posteriormente, podem ser vistos como tipos indutivos.

As regras de computação, para $\beta$-redução, são escritas uma para o caso base, $p_0$, e outra para o passo indutivo, $p_S$:

\begin{center}
    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S, 0_{\mathbb{N}}) = p_0 : P$}
    \DisplayProof


    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S, succ_{\mathbb{N}}(n)) = p_S(n, ind_{\mathbb{N}}(p_0, p_S, n)) : P$}
    \DisplayProof
\end{center}

Exemplo:

\begin{definition}[Adição, \cite{rijke2022}]
    Definindo uma função $$add_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$$
    que satisfaça a especificação:
    $$add_{\mathbb{N}}(m, 0_{\mathbb{N}}) = m$$
    $$add_{\mathbb{N}}(m, succ_{\mathbb{N}}(n)) = succ_{\mathbb{N}}(add_{\mathbb{N}}(m, n))$$
    $add_{\mathbb{N}}(m, n)$ será denotado por $m + n$
\end{definition}

Para sua construção, é necessário usar a regra de eliminação para $P = \mathbb{N}$. Logo, as premissas se tornam:

$$m : \mathbb{N} \vdash \mathbb{N}$$
$$m: \mathbb{N} \vdash add-zero_{\mathbb{N}} (m) : \mathbb{N}$$
$$m: \mathbb{N} \vdash add-succ_{\mathbb{N}} (m) : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$$

e sua conclusão é:

$$m : \mathbb{N} \vdash add_{\mathbb{N}}(m) := ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$$

O termo $add-zero_{\mathbb{N}} (m)$ é o próprio $m$, já para a adição do sucessor, é necessário saber qual o comportamento da soma para o sucesso, que é a seguinte:

$$add_{\mathbb{N}}(m, succ_{\mathbb{N}}(n)) = succ_{\mathbb{N}}(add_{\mathbb{N}}(m, n))$$

Logo, $add-succ_{\mathbb{N}}(m)$ é o mesmo que o sucessor da adição:

$$add-succ_{\mathbb{N}}(m) := \lambda n . succ_{\mathbb{N}}$$

A árvore de derivação desse termo é o seeguinte:

\begin{prooftree}
    \AxiomC{$\vdash \mathbb{N} \to \mathbb{N}$}
    \AxiomC{$\vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{($\mathbb{N}$-intro)}
    \BinaryInfC{$n : \mathbb{N} \vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{(weak)}
    \UnaryInfC{$m : \mathbb{N}, n : \mathbb{N} \vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{($\to$-intro)}
    \UnaryInfC{$m : \mathbb{N} \vdash \lambda n . succ_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
    \UnaryInfC{$m : \mathbb{N} \vdash add-succ_{\mathbb{N}}(m) := \lambda n . succ_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
\end{prooftree}


A regra de inferência final se torna:

\begin{prooftree}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m : \mathbb{N} \vdash \mathbb{N} \text{ Type}$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m: \mathbb{N} \vdash add-zero_{\mathbb{N}} (m) := m : \mathbb{N}$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m: \mathbb{N} \vdash add-succ_{\mathbb{N}} (m) : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
    \TrinaryInfC{$m : \mathbb{N} \vdash ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$}
    \UnaryInfC{$m : \mathbb{N} \vdash add_{\mathbb{N}}(m) := ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$}
\end{prooftree}


\subsubsection{O Tipo dos Booleanos}

O tipo booleano é um tipo que possui dois elementos: um que corresponde ao valor verdadeiro na lógica proposicional e outro que corresponde ao valor falso.

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash Bool \text{ Type}$}
\end{prooftree}

Sua regra de introdução é:

\begin{center}
    \AxiomC{}
    \LeftLabel{($bool$-intro)}
    \UnaryInfC{$\vdash false : Bool$}
    \DisplayProof
    \AxiomC{}
    \LeftLabel{$\qquad$($bool$-intro)}
    \UnaryInfC{$\vdash true : Bool$}
    \DisplayProof
\end{center}

O tipo dos booleanos é um tipo indutivo, logo sua eliminação segue uma forma parecida à regra dos naturais:

\begin{prooftree}
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_1 : P$}
    \LeftLabel{($Bool$-elim)}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1) : Bool \to P$}
\end{prooftree}

Suas regras de $\beta$-redução são as seguintes:

\begin{center}
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : Bool \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1, false) = p_0 : P$}
    \DisplayProof

    \hfill
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : Bool \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1, true) = p_1 : P$}
    \DisplayProof
\end{center}

Exemplo

Um exemplo é a função de negação, que pega $true$ e retorna $false$, e vice-versa. Essa função pode ser construida usando a regra da eliminação dos booleanos usando $P := Bool$:

\begin{prooftree}
    \AxiomC{$b : Bool \vdash Bool \text{ Type}$}
    \AxiomC{$b : Bool \vdash false : Bool$}
    \AxiomC{$b : Bool \vdash true : Bool$}
    \LeftLabel{($Bool$-elim)}
    \TrinaryInfC{$\vdash ind_{Bool}(true, false) : Bool \to Bool$}
\end{prooftree}

Pelas regras de $\beta$-redução é possível ver que essa construção está correta.

\subsubsection{O Sistema T de Gödel}


\end{document}