\documentclass[../main.tex]{subfiles}

\begin{document}


\section{Teoria dos Tipos Simples}

O cálculo $\lambda$ não-tipado possui alguns entraves ao tentar traduzir as funções matemáticas para seus termos. Um desses entraves é o fato que as funções matemáticas são mapeamentos entre dois conjuntos. Ou seja, essas funções possuem em sua definição os valores que vão esperar e os possíveis valores que vão retornar. A função soma $+:\mathbb{N} \to \mathbb{N}$ não pode aceitar os valores $true$ ou $false$. Porém, nas codificações do cálculo $\lambda$ descrito até então (Sem contar com os modelos), isso é possível. Por exemplo, é possível perceber que $false$ e $0$ são definidos pelo mesmo termo $\lambda xy . y$ (a definição de $0$ é $\alpha$-equivalente a essa), o que pode gerar confusão em sua aplicação.

Outro problema do Cálculo $\lambda$ não-tipado é o fato de poder existir recursões infinitas através de termos como $\Omega$ e $\Delta$. A tipagem dos termos faz com que esse tipo de fenômeno não ocorra. O que retira a Turing-completude, mas facilita outras coisas.

Para fazer essa descrição ser mais detalhada e evitar esse tipo de erro, Church introduziu tipos.

\subsection[Cálculo lambda simplesmente tipado (STLC)]{Cálculo $\lambda$ simplesmente tipado (ST$\lambda$C)}

\subsubsection{Tipos simples}

Uma forma simples de começar a tipagem dos $\lambda$-termos é considerando uma coleção de variáveis de tipos e uma forma de produzir mais tipos através dessa coleção, chamado de \emph{tipo funcional}

Seja $\mathbb{V}$ a coleção infinita de variáveis de tipos $\mathbb{V} = \{ \alpha, \beta, \gamma, \dots \}$, então:

\begin{definition}[A coleção de todos os tipos simples]
    A coleção dos tipos simples $\mathbb{T}$ é definida por:
    \begin{enumerate}
        \item (Variável de tipos) Se $\alpha \in \mathbb{V}$,  então $\alpha \in \mathbb{T}$
        \item (Tipo funcional) Se $\sigma, \tau \in \mathbb{T}$, então $(\sigma \to \tau) \in \mathbb{T}$.
    \end{enumerate}
    Na BNF, $\mathbb{T} = \mathbb{V} | \mathbb{T} \to \mathbb{T}$
\end{definition}

Os parenteses no tipo funcional são associativos à direita, ou seja o tipo $\alpha_1 \to \alpha_2 \to \alpha_3 \to \alpha_4$ é $(\alpha_1 \to (\alpha_2 \to (\alpha_3 \to \alpha_4)))$

Tipos simples arbitrários serão escritos com letras gregas minúsculas (Com excessão do $\lambda$) como $\sigma, \tau, \dots$, mas também podem ser escrito como letras latinas maiúsculas $A, B, \dots$ na literatura.


As variáveis de tipos são representações abstratas de tipos básicos como os números naturais $\mathbb{N}$ ou a coleção de todas as listas $\mathbb{L}$. Esses tipos serão explorados mais à frente. Já os tipos funcionais representam funções na matemática como por exemplo $\mathbb{N} \to \mathbb{N}$, o conjunto de funções que leva dos naturais para os naturais, ou $(\mathbb{N} \to \mathbb{Z}) \to \mathbb{Z} \to \mathbb{N}$, o conjunto de funções que recebem como entrada uma função que leva dos naturais aos inteiros e um inteiro e retorna um natural.

A sentença "O termo $M$ possui tipo $\sigma$" é escrita na forma $M : \sigma$. Todo termo possui um tipo único, logo se $x$ é um termo e $x : \sigma$ e $x : \tau$, então $\sigma \equiv \tau$.

Como os tipos foram introduzidos para lidar com o cálculo $\lambda$, eles devem ter regras para lidar com as operações de aplicação e abstração.

\begin{enumerate}
    \item (\emph{Aplicação}): No cálculo $\lambda$, sejam $M$ e $N$ termos, podemos fazer uma aplicação entre eles no estilo $MN$. Para entender como entram os tipos, é possível recordar de onde surge a intuição para a aplicação. Seja $f : \mathbb{N} \to \mathbb{N}$ a função $f(x) = x^2$, então, a aplicação de $3$ em $f$ é $f(3) = 3^2$. Nesse exemplo, omite-se o fato que para aplicar $3$ a $f$, $3$ tem que estar no domínio de $f$, ou seja, $3 \in \mathbb{N}$. No caso do cálculo $\lambda$, para aplicar $N$ em $M$, $M$ deve ter um tipo funcional, na forma $M : \sigma \to \tau$, e $N$ deve ter como tipo o primeiro tipo que aparece em $M$, ou seja $N : \sigma$. 
    \item (\emph{Abstração}): No cálculo $\lambda$, seja $M$ um termo, podemos escrever um termo $\lambda x . M$. A abstração "constroi" a função. Para a tipagem, seja $M : \tau$ e $x : \sigma$, então $\lambda x : \sigma . M : \sigma \to \tau$. É possível omitir o tipo da variável, escrevendo no estilo: $\lambda x . M : \sigma \to \tau$.
\end{enumerate}


Alguns exemplos:

\begin{enumerate}
    \item Seja $x$ do tipo $\sigma$, a função identidade é escrita na forma $\lambda x . x : \sigma \to \sigma$.
    \item O combinador $\text{\textbf{B}} \equiv \lambda xyz . x(yz)$ é tipado na forma $\text{\textbf{B}} : (\sigma \to \tau) \to (\rho \to \sigma) \to \rho \to \tau$.
    \item O combinador $\Delta \equiv \lambda x . xxx$ não possui tipagem. Isso ocorre pois, na aplicação $xx$, $x$ precisa ter como tipo $\sigma \to \tau$ e $\sigma$, mas como $x$ só pode ter um tipo, então $\sigma \to \tau \equiv \sigma$. O que não é possível em $\mathbb{T}$. Logo $\Delta$ (e $\Omega$ por motivos similares), não faz parte da teoria dos tipos simples.
\end{enumerate}

O último exemplo mostra que o teorema do ponto fixo não ocorre para todos os termos na teoria dos tipos simples e que não existe recursão infinita, fazendo com que a teoria dos tipos simples deixe de ser turing-completa.

\subsubsection{Abordagens para a tipagem}

Existem duas formas de tipar um $\lambda$-termo:

\begin{enumerate}
    \item (\emph{Tipagem à la Church} / \emph{Tipagem explícita} / \emph{Tipagem intrínseca} / \emph{Tipagem ontológica}) Nesse estilo de tipagem, só termos que possuem tipagem que satisfaz a construção de tipos interna à teoria são aceitos. Cada termo possui um tipo único.
    \item (\emph{Tipagem à la Curry} / \emph{Tipagem implícita} / \emph{Tipagem extrínseca} / \emph{Tipagem semântica}) Nesse estilo de tipagem, os termos são os mesmos do cálculo $\lambda$ não tipado e pode-se não definir o tipo do termo na sua introdução, mas deixá-lo aberto. Os tipos são buscados para o termo, por tentativa e erro.
\end{enumerate}


\textbf{Exemplos}

\begin{enumerate}
    \item (Tipagem intrínseca): Seja $x$ do tipo $\alpha \to \alpha$ e $y$ do tipo $(\alpha \to \alpha) \to \beta$, então $yx$ possui o tipo $\beta$. Se $z$ possuit tipo $\beta$ e $u$ possuir tipo $\gamma$, então $\lambda zu . z$ tem tipo $\beta \to \gamma \to \beta$ e a aplicação $(\lambda zu . z)(yx)$ é permitida pois o tipo $\beta$ de $yx$ equivale ao tipo $\beta$ que $\lambda zu . z$ recebe.
    \item (Tipagem extrínseca): Nessa tipagem, começa-se com o termo $M \equiv (\lambda zu . z)(yx)$ e tenta-se adivinhar qual seu tipo e o tipo de suas variáveis. É possível notar que $(\lambda zu . z)(yx)$ é uma aplicação, então $(\lambda zu . z)$ precisa ter um tipo $A \to B$, $yx$ precisa ter um tipo $A$ e $M$ terá um tipo $B$. Mas se $\lambda zu . z$ possui o tipo $A \to B$, então $\lambda u . z$ possui o tipo $B$ e, como o termo é uma abstração, $B$ precisa ser um tipo funcional, ou seja $B \equiv C \to D$. Logo $u : C$ e $z : D$. Já no caso de $yx : A$, $y$ precisa ter um tipo funcional para ser aplicado a $x$, logo sendo $x : E$, $y : E \to F$. Logo temos que $x : E, y : E \to A, z : A, u : C$. Só é necessário então substituir $A, C, E$ com tipos variáveis como $\alpha, \beta, \gamma$: $x : \alpha, y : \alpha \to \beta, z : \beta, u : \gamma$.
\end{enumerate}

No caso do exemplo 2, é possível escrever $x : \alpha, y : \alpha \to \beta, z : \beta, u : \gamma \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$. A lista à esquerda da $\vdash$ (lê-se catraca) é chamada de \emph{contexto}.

\subsubsection{Regras de derivação e Cálculo de sequêntes}

É necessário, na tipagem intrínseca, definir a coleção de todos os $\lambda$-termos tipados:

\begin{definition}[$\lambda$-termos pré-tipados]
    A coleção $\Lambda_{\mathbb{T}}$ de $\lambda$-termos pré-tipados é definida pela BNF: \\
    $\Lambda_{\mathbb{T}} = V | (\Lambda_{\mathbb{T}} \Lambda_{\mathbb{T}}) | (\lambda V :  \mathbb{T} . \Lambda_{\mathbb{T}})$
\end{definition}

Para expressar as tipagens dos $\lambda$-termos, é necessário desenvolver um conjunto de definições que ainda não foram mostradas:

\begin{definition}
    \hfil
    \begin{enumerate}
        \item Uma \emph{sentença} é $M : \sigma$, onde $M \in \Lambda_{\mathbb{T}}$ e $\sigma \in \mathbb{T}$. Nessa sentença, $M$ é chamado de \emph{sujeito} e $\sigma$ de \emph{tipo}
        \item  Uma \emph{declaração} é uma sentença com uma \emph{variável} como sujeito
        \item Um \emph{Contexto} é uma lista, possivelmente nula, de declarações com diferentes sujeitos
        \item Um \emph{Juizo} possui a forma $\Gamma \vdash M : \sigma$, onde $\Gamma$ é o contexto e $M : \sigma$ é uma sentença.
    \end{enumerate}
\end{definition}

Para estudar a tipagem, será utilizado um sistema de derivações trazido da lógica chamado de \emph{Cálculo de sequêntes}. O cálculo de sequêntes dá a possibilidade de gerar juizos de forma formal utilizando árvores de derivação no estilo: 

\begin{prooftree}
    \def\fCenter{\mbox{\ $\vdash$\ }}
    \AxiomC{$\text{premissa } 1$}

    \AxiomC{$\text{premissa } 2$}

    \AxiomC{$\dots$}

    \AxiomC{$\text{premissa } n$}

    \RightLabel{}
    \QuaternaryInfC{$\text{Conclusão}$}
\end{prooftree}


Acima da linha horizontal estão as premissas, que são cada uma um juizo, e abaixo da linha horizontal está a conclusão, que é em si um juizo também. A linha marca uma regra de derivação específica da teoria que se está trabalhando.

\begin{definition}[Regras de derivação para o ST$\lambda$C]
    \hfil
    \begin{itemize}
        \item (\emph{var}) $\Gamma \vdash x : \sigma$, dado que $x : \sigma \in \Gamma$.
        \item (\emph{appl}) \begin{prooftree}
            \def\fCenter{\mbox{\ $\vdash$\ }}
            \AxiomC{$\Gamma \vdash M : \sigma \to \tau$}
            \AxiomC{$\Gamma \vdash N : \sigma$}
            \RightLabel{appl}
            \BinaryInfC{$\Gamma \vdash MN : \tau$}
        \end{prooftree}
        \item (\emph{abst}) \begin{prooftree}
            \def\fCenter{\mbox{\ $\vdash$\ }}
            \AxiomC{$\Gamma, x : \sigma \vdash M : \tau$}
            \RightLabel{abst}
            \UnaryInfC{$\Gamma \vdash \lambda x : \sigma . M : \sigma \to \tau$}
        \end{prooftree}
    \end{itemize}
\end{definition}

A regra \emph{(var)} não possui premissas e possui como conclusão o fato que dado um contexto $\Gamma$, se existe uma declaração em $\Gamma$, essa declaração é derivável através de $\Gamma$. Essa primeira regra é tratada como axioma em (Hindley, 1997), pois, assim como todo axioma, ela é derivável sem precisar de premissas. Na construção da árvore de dedução, essa regra está no topo como uma "raiz".

A regra \emph{(appl)} é equivalente no cálculo ao que foi feito antes. Essa regra também é chamada na literatura de $\to - elim$ ou $\to E$

A regra \emph{(abs)} é equivalente no cálculo à abstração e pode ser chamada na literatura de $\to - intro$ ou $\to I$.

\textbf{Exemplo:}

\begin{prooftree}
    \def\fCenter{\mbox{\ $\vdash$\ }}
    \AxiomC{(1) $y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{(2) $y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{(3) $ y : \alpha \to \beta, z : \alpha \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{(4) $ y : \alpha \to \beta \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{(5) $\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta$}
\end{prooftree}

Dada a derivação já montada, sua leitura pode ser feita de baixo para cima, feito levando em conta as premissas mais fundamentais até a conclusão final, de forma a adicionar informação aos juízos a cada passo, ou de cima para baixo, feito para entender qual caminho leva até o objetivo final.

\begin{enumerate}
    \item Os passos (1) e (2) usam a regra (\emph{var})
    \item O passo (3) usa a regra (\emph{app}) usando (1) e (2) como premissas
    \item O passo (4) usa a regra (\emph(abs)) com (3) como premissa
    \item O passo (5) usa a regra (\emph(abs)) com (4) como premissa
\end{enumerate}

As regras de derivação podem ser entendidas em outros contextos:

\emph{Matemática}: Seja $A \to B$ o conjunto de todas as funções de $A$ para $B$, então as regras se tornam:
\begin{enumerate}
    \item (\emph{aplicação funcional}) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{se $f$ é um membro de $A \to B$}
        \AxiomC{e se $c \in A$}
        \BinaryInfC{então $f(c) \in B$}
    \end{prooftree}
    \item (\emph{abstração funcional}) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{Se para $x \in A$ segue-se que $f(x) \in B$}
        \UnaryInfC{então $f$ é membro de $A \to B$}
    \end{prooftree}
\end{enumerate}

\emph{Lógica}: Seja $A \Rightarrow B$ "$A$ implica em $B$", então pode-se ler $A \to B$ como $A \Rightarrow B$. As regras se tornam:

\begin{enumerate}
    \item ($\Rightarrow - elim$) \begin{prooftree}
        \def\fCenter{\mbox{\ $\vdash$\ }}
        \AxiomC{$A \to B$}
        \AxiomC{$A$}
        \BinaryInfC{$B$}
    \end{prooftree}
    \item ($\Rightarrow - intro$) \begin{prooftree}
        \alwaysNoLine
        \AxiomC{$A$}
        \UnaryInfC{$\vdots$}
        \alwaysSingleLine
        \UnaryInfC{$B$}
    \end{prooftree}
\end{enumerate}


A regra de eliminação é denominada de \emph{Modus Ponens}. Ambas as regras como estão escritas aí são parte das regras definidas na \emph{Dedução Natural}, um cálculo análogo ao cálculo de sequêntes (Toda árvore definida na dedução natural possui um equivalente no cálculo de sequêntes). Esse estilo de dedução natural é chamado de \emph{Dedução natural no estilo de Gentzen}, para diferenciá-lo da \emph{Dedução natural no estilo de Fitch} que é escrito como:

% \begin{equation*}
%     \begin{fitch}
%     \fh A A A & Assumption \\
%     \fa B B B & Main Proof Step \\
%     \fa C C C & Another Main Proof Step\\
%     \fa \fh D D D & New Assumption \\
%     \fa \fa E E E & Subproof Step \\
%     \fa \fa F F F & Another Subproof Step \\
%     \fa G G G & Main Proof Step \\
%     \fa H H H & Main Proof Step
%     \end{fitch}
%     \end{equation*}

\begin{definition}[$\lambda_\to$-termos legais]
    Um termo $M$ pré-tipado em $\lambda_\to$ é chamado \emph{legal} se existe um contexto $\Gamma$ e um tipo $\rho$ tal que $\Gamma \vdash M : \rho$.
\end{definition}

\subsubsection{Problemas resolvidos no STLC}

No geral, existem três tipos de problemas relacionados a julgamentos na teoria dos tipos:

\begin{enumerate}
    \item \emph{Bem-tipagem} (\emph{Well-typedness}) ou \emph{Tipabilidade}: esse problema surge da questão $$? \vdash \text{termo } : ?$$ Ou seja, saber se um termo é legal e, se não é, mostrar onde sua contrução falha. \\
    (1a) \emph{Atribuição de tipos}, que surge da questão: $$\text{contexto } \vdash \text{termo } : ?$$. Ou seja, dado um contexto e um termo, derive seu tipo.
    \item \emph{Checagem de tipos}, que surge da questão $$\text{contexto } \vdash^{?} \text{termo } : \text{tipo}$$. Ou seja, se é realmente verdadeiro que o termo possui o tipo no determinado contexto.
    \item \emph{Encontrar o termo}, que surge da questão: $$\text{contexto } \vdash ? : \text{tipo}$$. Um tipo particular desse problema é quando o contexto é vazio, ou seja $$\emptyset \vdash ? : \text{tipo}$$. 
\end{enumerate}

Todos esses problemas são \emph{decidíveis} em $\lambda_\to$. Ou seja, para cada um deles existe um \emph{algoritmo} (um conjunto de passos) que produz a resposta. Em outros sistemas, encontar um termo se torna \emph{indecidível}.

\subsubsection[Bem-tipagem no STLC]{Bem-tipagem em $\lambda_\to$}

Para exemplificar os passos necessários para resolver a bem-tipagem em $\lambda_\to$, será utilizado o exemplo descrito em 1.1.3, dessa vez passo a passo.

O objetivo é mostrar que o termo $M \equiv \lambda y : \alpha \to \beta . \lambda z : \alpha . yz$ é um termo legal. Logo, precisamos encontrar um contexto $\Gamma$ e um tipo $\rho$ tal que $\Gamma \vdash M : \rho$.

Primeiro, como não existem variáveis livres em $M$, o contexto inicial pode ser considerado vazio: $\Gamma = \emptyset$.

Inicialmente, o primeiro passo é descobrir qual a premissa, ou premissas, que gera o termo e a regra de dedução:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Como a primeira parte do termo é um $\lambda y$, a única regra possível inicialmente é a abstração:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Novamente, a única regra possível é a abstração:


\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Sobrou do lado direito da catraca o termo $yz$ que, vendo o contexto, é a aplicação de outros dois termos, logo a única regra possível é a aplicação:

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

Como as premissas mais superiores são geradas de (\emph{var}), não há mais nenhum passo de premissas e a tipagem pode ser realizada de cima para baixo.

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \dots$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}


\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : \dots$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash y : \alpha \to \beta$}
    \AxiomC{$y : \alpha \to \beta, z : \alpha \vdash z : \beta$}
    \RightLabel{appl}
    \BinaryInfC{$ y : \alpha \to \beta, z : \alpha  \vdash yz : \beta$}
    \RightLabel{abs}
    \UnaryInfC{$ y : \alpha \to \beta  \vdash \lambda z : \alpha . yz : \alpha \to \beta$}
    \RightLabel{abs}
    \UnaryInfC{$\emptyset \vdash \lambda y : \alpha \to \beta . \lambda z : \alpha . yz : (\alpha \to \beta) \to \alpha \to \beta$}
\end{prooftree}

Se existisse algum problema no caso de encontrar variáveis com tipagem incongruente nas últimas premissas ou não ter mais nenhum passo, então o termo não seria bem-tipado.

% \begin{mathpar}
%     \inferrule
%         { aa \\ bb }
%         { cc }
%     \quad(\textsc { Yop })
% \end{mathpar}


\subsubsection[Checagem de tipos no STLC]{Checagem de tipos em $\lambda_\to$}

Seja o juizo $$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$$

é necessário construir uma árvore de inferências que demonstre que $\gamma \to \beta$ é o tipo correto do termo do lado direito.

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash^?(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

Usando a regra da aplicação, tem-se:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash yx : \text{ ? }$}
    \RightLabel{appl}
    \BinaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash^?(\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

O lado direto se segue da regra da aplicação:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash x : \alpha \to \alpha$}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash y : (\alpha \to \alpha) \to \beta $}
    \RightLabel{appl}
    \BinaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash yx : \text{ ? }$}
\end{prooftree}

Usando essa subárvore, pode-se ver que $yx$ possui o tipo $yx : \beta$.

O lado esquerdo se segue da abstração:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \text{ ? }$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

abstraindo novamente:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \text{ ? }$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

Agora, é possível "descer" novamente "coletando" os tipos que foram deixados para trás:

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \text{ ? }$}
\end{prooftree}

e

\begin{prooftree}
    \AxiomC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta \vdash \lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$}
\end{prooftree}

Seja $\Gamma \equiv x : \alpha \to \alpha, y : (\alpha \to \alpha) \to \beta$, a árvore completa fica:


\begin{prooftree}
    \AxiomC{$\Gamma, z : \beta, u : \gamma \vdash z : \beta $}
    \RightLabel{abst}
    \UnaryInfC{$\Gamma, z : \beta \vdash \lambda u : \gamma . z : \gamma \to \beta$}
    \RightLabel{abst}
    \UnaryInfC{$\Gamma \vdash \lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$}
    
    \AxiomC{$\Gamma \vdash x : \alpha \to \alpha$}
    \AxiomC{$\Gamma \vdash y : (\alpha \to \alpha) \to \beta $}
    \RightLabel{appl}
    \BinaryInfC{$\Gamma \vdash yx : \beta$}

    \RightLabel{appl}
    \BinaryInfC{$\Gamma \vdash (\lambda z : \beta . \lambda u : \gamma . z)(yx) : \gamma \to \beta$}
\end{prooftree}

Dessa forma, é possível perceber que sim, a aplicação de $\lambda z : \beta . \lambda u : \gamma . z : \beta \to \gamma \to \beta$ com $yx : \beta$ possui o tipo $\gamma \to \beta$. 


\subsubsection[Encontrar termos no STLC]{Encontrar termos em $\lambda_\to$}

Seja o tipo $A \to B \to A$. A pergunta que fica é: é possível encontrar um termo para esse tipo? Essa pergunta é, vista do ponto da lógica, a mesma coisa que "é possível computar uma prova para essa proposição?" (Isso será visto mais adiante). Isso é a mesma coisa que: $\text{ ? } : A \to B \to A$. Pelas regras de inferência:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$\text{ ? } \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Supondo um termo $x : A$, pode-se escrever a árvore como:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : A \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

E supondo um outro termo $y : B$, pode-se escrever como:

\begin{prooftree}
    \AxiomC{?}
    \RightLabel{?}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Como já existe um termo de tipo $A$, pode-se substituir o termo desconhecido por $x$:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text { ? } : B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}

Usando a regra da abstração:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda y . x: B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \text{ ? } : A \to B \to A$}
\end{prooftree}


Novamente:

\begin{prooftree}
    \AxiomC{$x : A, y : B \vdash x : A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda y . x: B \to A$}
    \RightLabel{abst}
    \UnaryInfC{$x : A, y : B \vdash \lambda xy . x : A \to B \to A$}
\end{prooftree}

\subsubsection[Propriedades gerais do STLC]{Propriedades gerais do ST$\lambda$C}

Ficaram faltando nas definições anteriores a explicação de algumas propriedades gerais da sintaxe do ST$\lambda$C.

Algumas propriedades sobre os contextos:

\begin{definition}[(Domínio, subcontexto, permutação, projeção)]
\hfill
\begin{enumerate}
    \item Se $\Gamma \equiv x_1 : \sigma_1, \dots, x_n : \sigma_n$, então o \emph{domínio} de $\Gamma$ ou $dom(\Gamma)$ é a lista $(x_1, \dots, x_n)$.
    \item Um contexto $\Gamma'$ é um \emph{subcontexto} do contexto $\Gamma$, ou $\Gamma' \subseteq \Gamma$ se todas as declarações que ocorrem em $\Gamma'$ também ocorrem em $\Gamma$ na mesma ordem.
    \item Um contexto $\Gamma'$ é uma \emph{permutação} do contexto $\Gamma$, ou $\Gamma' \subseteq \Gamma$ se todas as declarações que ocorrem em $\Gamma'$ também ocorrem em $\Gamma$ e vice-versa
    \item Se $\Gamma$ é um contexto e $\Phi$ o conjunto de variáveis, então a \emph{projeção} de $\Gamma$ em $\Phi$, ou $ \Gamma \upharpoonright \Phi$, é o subcontexto $\Gamma'$ de $\Gamma$ com $dom(\Gamma') = dom(\Gamma) \cap \Phi$
\end{enumerate}

Em uma lista, a ordem dos elementos importa.
    
\end{definition}

Exemplo: Seja $\Gamma \equiv y : \sigma, x_1 : \rho_1, x_2 : \rho_2, z : \tau, x_3 : \rho_3$, então:

\begin{enumerate}
    \item $dom(\emptyset) = ()$, onde $\emptyset$ é chamado de lista vazia;
    \item $dom(\Gamma) = (y, x_1, x_2, z, x_3)$
    \item $\emptyset \subseteq (x_1 : \rho_1, z : \tau) \subseteq \Gamma$ 
    \item $\Gamma \upharpoonright \{ z, u, x_1 \} = x_1 : \rho_1, z : \tau$
\end{enumerate}

Uma propriedade importante de $\lambda_{\rightarrow}$ é a seguinte:

\begin{lemma}(Lemma das variáveis livres)
    \newline
    Se $\Gamma \vdash L : \sigma$, então $FV(L) \subseteq dom(\Gamma)$.
\end{lemma}

Como consequência desse lemma, seja $x$ uma variável livre que ocorre em $L$, então $x$ possui um tipo, o qual é declarado no contexto $\Gamma$. Em um juizo, não é possível ocorrer confusão sobre o tipo de qualquer variável, pois todas as variáveis ligadas possuem seu tipo, antes da ligação $\lambda$.

Para provar esse lemma, é necessário usar uma técnica de prova chamada de \emph{indução estrutural}. Essa indução ocorre da seguinte forma:

Seja $\mathcal{P}$ a propriedade geral que se quer provar para uma expressão arbitrária $\mathcal{E}$, procede-se da seguinte forma:

\begin{itemize}
    \item Assumindo que $\mathcal{P}$ é verdadeira para toda expressão $\mathcal{E}'$ usada no construto $\mathcal{E}$ (\emph{Hipótese Indutiva}),
    \item e provando que $\mathcal{P}$ também é verdadeira para $\mathcal{E}$.
\end{itemize}

\emph{Prova do Lemma:} Seja $\mathcal{J} \equiv \Gamma \vdash L : \sigma$, e suponha que $\mathcal{J}$ é a conclusão final de uma derivação e assuma que o conteudo do Lemma vale para as premissas usadas para inferir a conclusão.

Pela definição das regras de inferência, existem três possibilidades de regra para conclusão: (\emph{var}), (\emph{appl}) e (\emph{abst}). Provando por casos:

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma \vdash x : \sigma$ se seguindo de $x : \sigma \in \Gamma$. O $L$ do lemma é o $x$ e precisamos provar que $FV(x) \subseteq dom(\Gamma)$. Mas isso é consequência direta de $x : \sigma \in \Gamma$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ deve ter a forma $\Gamma \vdash MN : \tau$ e precisa-se provar que $FV(MN) \in dom(\Gamma)$. Por indução, a regra já é válida para as premissas de (\emph{appl}), que são $\Gamma \vdash M : \sigma \to \tau$ e $\Gamma \vdash N : \sigma$. \\
    Assim, pode-se assumir que $FV(M) \subseteq dom(\Gamma)$ e $FV(N) \subseteq dom(\Gamma)$. Como $FV(MN) = FV(M) \cup FV(N)$, então $FV(MN) \subseteq dom(\Gamma)$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ deve ter a forma $\Gamma \vdash \lambda x : \sigma . M : \sigma \to \tau$ e precisa-se provar que $FV(\lambda x : \sigma . M) \in dom(\Gamma)$. Por indução, a regra já é válida para a premissa de (\emph{abst}), que é $\Gamma, x : \sigma \vdash M : \tau$. \\
    Assim, pode-se assumir que $FV(M) \subseteq dom(\Gamma) \cup \{ x \}$. Como $FV(\lambda x : \sigma . M) = FV(M) \backslash \{ x \}$, então $FV(M) \backslash \{ x \} \subseteq dom(\Gamma)$.
\end{enumerate}
\hfill Outras propriedades também podem ser provadas no mesmo estilo de indução:

\begin{lemma}(Afinamento, Condensação, Permutação)
    \begin{enumerate}
        \item (\emph{Afinamento}) Sejam $\Gamma'$ e $\Gamma''$ contextos tais que $\Gamma' \subseteq \Gamma''$. Se $\Gamma' \vdash M : \sigma$, então $\Gamma'' \vdash M : \sigma$
        \item (\emph{Condensação}) Se $\Gamma \vdash M : \sigma$, então também  $\Gamma \upharpoonright FV(M) \vdash M : \sigma$
        \item (\emph{Permutação}) Se $\Gamma \vdash M : \sigma$ e $\Gamma'$ é uma permutação de $\Gamma$, então $\Gamma'$ também é um contexto e $\Gamma' \vdash M : \sigma$.
    \end{enumerate}
\end{lemma}

explicação:

\begin{itemize}
    \item O "afinamento" de um contexto é uma extensão do contexto obtida ao adicionar declarações extras com novas variáveis. O lema anterior diz que: se $M$ é tem tipo $\sigma$ em um contexto $\Gamma'$, então $M$ também terá um tipo $\sigma$ em um contexto "mais fino" $\Gamma'$. Ou seja, a validade do tipo de $M$ não muda ao adicionar novas declarações ao contexto. 
    \item O lema da "condensação" diz que declarações $x : \rho$ podem ser retiradas de $\Gamma$ caso $x$ não ocorra livre em $M$. Ou seja, ele só deixa declarações relevantes à $M$.
    \item O lema da "permutação" diz que não importa o jeito que o contexto foi ordenado e também que declarações no contexto são mutualmente independentes, então não existe impedimento teórico para a permutação do contexto. (Isso não vai ser verdadeiro em todas as teorias)
\end{itemize}

\emph{Prova do (1)}: A prova será feita por indução no juizo $\mathcal{J} \equiv \Gamma' \vdash M : \sigma$, assumindo que $\Gamma' \subseteq \Gamma''$. Existem três casos para considerar correspondentes a cada regra de inferência:

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash x : \sigma$ se seguindo de $x : \sigma \in \Gamma'$. Mas se $\Gamma' \subseteq \Gamma''$, então $x : \sigma \in \Gamma''$. Desse modo, usando (\emph{var}) tem-se que $\Gamma'' \vdash x : \sigma$. 
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash MN : \tau$ e precisa-se provar que $\Gamma'' \vdash MN : \tau$. Por indução, o afinamento é válido em $\Gamma' \vdash M : \sigma \to \tau$ e $\Gamma' \vdash N : \tau$. Mas, sendo assim, tem-se que $M \in \Gamma'$ e $N \in \Gamma'$, logo: $M \in \Gamma''$ e $N \in \Gamma''$ e, usando a regra  (\emph{appl}) em cima de $\Gamma'' \vdash M : \sigma \to \tau$ e $\Gamma'' \vdash N : \tau$, tem-se que $\Gamma'' \vdash MN : \tau$. 
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ tem que ter a forma $\Gamma' \vdash \lambda x : \rho . L : \rho \to \tau$. Temos que provar que $\Gamma' \vdash \lambda x : \rho . L : \rho \to \tau$, assumindo que $x \not\in dom(\Gamma'')$. Por indução na regra, temos que o "afinamento" também é válido para $\Gamma', x : \rho \vdash L : \tau$. Mas, como $x \not\in dom(\Gamma'')$, então podemos criar o contexto $\Gamma'', x : \rho$. E é possível ver que $\Gamma', x : \rho \subseteq \Gamma'', x : \rho$. Dessa forma, se segue que: $\Gamma'', x : \rho \vdash L : \tau$ e, através da regra, $\Gamma'' \vdash \lambda x : \rho . L : \rho \to \tau$
\end{enumerate}

As provas das outras duas partes se seguem de forma similiar e são deixadas para o leitor como exercício.

Outro lema importante é o seguinte:

\begin{lemma}(Lema da Geração)
    \hfill
    \begin{enumerate}
        \item Se $\Gamma \vdash x : \sigma$, então $x : \sigma \in \Gamma$
        \item Se $\Gamma \vdash MN : \tau$, então existe um tipo $\sigma$ tal que $\Gamma \vdash M : \sigma \to \tau$ e $\Gamma \vdash N : \sigma $
        \item Se $\Gamma \vdash \lambda x : \sigma . M : \rho$, então existe um $\tau$ tal que $\Gamma, x : \sigma \vdash M : \tau$ e $\rho \equiv \sigma \to \tau$.
    \end{enumerate}
\end{lemma}

\emph{prova:} Pela inspeção das regras de inferência de $\lambda_{\rightarrow}$, é possível ver que não existe outra possibilidade a não ser as listadas no lema.

\begin{lemma}(Lema do subtermo)
    Se $M$ é legal, então todo subtermo de $M$ é legal.
\end{lemma}

Então, se existem $\Gamma_1$ e $\sigma_1$ tal que $\Gamma_1 \vdash M : \sigma_1$ e se $L$ é um subtermo de $M$, então existem $\Gamma_2$ e $\sigma_2$ tais que $\Gamma_2 \vdash L : \sigma_2$. Com essa descrição, é possível ver que a prova também se segue da indução nas regras.

\emph{prova}: Usando a indução e supondo $\Gamma \vdash x : \sigma$ como caso base, tem-se dois casos:

\begin{itemize}
    \item Se $M \equiv NL : \tau$, então tem-se que $\Gamma \vdash NL : \tau$, onde $N$ e $L$ são subtermos de $M$. Pelo lema da geração, existe um tipo $\sigma$ tal que $\Gamma \vdash N : \sigma \to \tau$ e $\Gamma \vdash L : \sigma $. Dessa forma, $N$ e $L$ são legais
    \item Se $M \equiv \lambda x . N : \rho$, então tem-se que $\Gamma \vdash  \lambda x . N : \rho$, onde $N$ é subtermo de $M$. Pelo lema da geração, existe um tipo $\tau$ tal que $\Gamma, x : \sigma \vdash M : \tau$ e $\rho \equiv \sigma \to \tau$. Dessa forma $M$ é legal e $\Gamma_2 \equiv \Gamma_1, x : \sigma$.
\end{itemize}

Uma propriedade importante da Teoria dos Tipos de Church é que cada termo possui um tipo único, que pode ser descrito no seguint lema:

\begin{lemma}(Unicidade dos tipos)
    Assuma que $\Gamma \vdash M : \sigma$ e $\Gamma \vdash M : \tau$, então $\sigma \equiv \tau$.
\end{lemma}

\emph{Prova}: Por indução na construção de $M$

\begin{theorem}(Decidabilidade)
    Em $\lambda_{\rightarrow}$, os seguintes problemas são decidíveis:
    \begin{enumerate}
        \item Boa-tipagem: $? \vdash term : ?$
        \item Checagem de tipos: $\text{contexto } \vdash^{?} \text{termo } : \text{tipo}$
        \item Encontrar termos: $\text{contexto } \vdash \text{?} : \text{tipo}$
    \end{enumerate}
\end{theorem}

\emph{Prova}: A prova pode ser encontrada em (Barendregt, 1992).

\subsubsection[Redução no STLC]{Redução no ST$\lambda$C}

Até agora, não havia sido definido o comportamento da $\beta$-redução no ST$\lambda$C. Para fazer isso, é necessário introduzir o seguinte lema:

\begin{lemma}(Lema da Substituição)
    Seja $\Gamma', x : \sigma, \Gamma'' \vdash M : \tau$ e $\Gamma' \vdash N : \sigma$, então $\Gamma', \Gamma'' \vdash M [x := N] : \tau$.
\end{lemma}

Esse lema diz que se em um termo legal $M$ for substituido todas as ocorrências da variável do contexto $x$ por um termo $N$ de mesmo tipo que $x$, então o resultado $M [x := N]$ possui o mesmo tipo que $M$.

\emph{prova}: Usando indução em cima do juizo $\mathcal{J} \equiv \Gamma', x : \sigma, \Gamma'' \vdash M : \tau$. 

\begin{enumerate}
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{var}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma', x : \sigma, \Gamma'' \vdash x : \sigma$. Se o contexto é bem formado, então $x : \sigma$ não está em $\Gamma''$ e $x \not\in FV(N)$. Com isso, pode-se inferir que $x [x:= N] : \sigma$.
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{appl}) \\
    Então $\mathcal{J}$ possui a forma $\Gamma' \vdash MN : \tau$, pela regra de inferência, temos dois juizos $\mathcal{J}' \equiv \Gamma' \vdash M : \rho \to \tau$ e $\mathcal{J}'' \equiv \Gamma' x : \sigma \vdash N :\rho$ para os quais vale o lema, logo supondo $\Gamma' \vdash L : \sigma$, temos que: $\Gamma', \Gamma'' \vdash M [x := N] : \rho \to \tau$ e $\Gamma', \Gamma'' \vdash N [x := L] :\rho$. Usando a regra da aplicação, temos: $\Gamma', \Gamma'' \vdash (M [x := L])N(x := L) : \tau$ que é a mesma coisa que $\Gamma', \Gamma'' \vdash (MN)(x := L) : \tau$. $\qed$
    \item Se $\mathcal{J}$ é a conclusão da regra (\emph{abst}) \\
    Então $\mathcal{J}$ tem que ter a forma $\Gamma' \vdash \lambda u : \rho . L : \rho \to \tau$. Logo existe um outro juizo $\mathcal{J}' \equiv \Gamma', x : \sigma, \Gamma'', u : \rho \vdash L : \tau$. Mas em $\mathcal{J}'$, $x : \sigma$ não pode ocorrer em $\Gamma'$, logo como $\Gamma' \vdash N : \sigma$, $x \not\in FV(N)$. Usando o lema, temos que $\Gamma', \Gamma'', u : \rho \vdash L [x := N] : \tau$. Usando a regra da abstração: $\Gamma', \Gamma'' \vdash \lambda u : \rho . (L [x := N]) : \rho \to \tau$, que é o mesmo que $\Gamma', \Gamma'' \vdash (\lambda u : \rho . L) [x := N] : \rho \to \tau$. $\qed$
\end{enumerate}

Tendo definido a substituição, pode-se definir a $\beta$-redução:

\begin{definition}($\beta$-redução de passo único para $\Lambda_{\mathbb{T}}$)
    \hfill
    \begin{enumerate}
        \item (Base) $(\lambda x : \sigma . M)N \rightarrow_{\beta} M[x := N]$
        \item (Compatibilidade) Como na definição 1.10
    \end{enumerate}
\end{definition}

Como os tipos não são importantes no processo de $\beta$-redução, o Teorema de Church-Rosser também se torna válido no $\lambda_{\rightarrow}$:

\begin{theorem}(Teorema de Church-Rosser)
    A propriedade de Church-Rosser também é válida para $\lambda_{\rightarrow}$
\end{theorem}

\begin{corollary}
    Suponha que $M =_{\beta} N$, então existe um $L$ tal que $M \twoheadrightarrow_{\beta} L$ e $N \twoheadrightarrow_{\beta} L$
\end{corollary}

\begin{lemma}(Redução do sujeito)
    Se $\Gamma \vdash L : \rho$ e se $L \twoheadrightarrow_{\beta} L'$, então $\Gamma \vdash L' : \rho$.
\end{lemma}

Esse lema final mostra que a $\beta$-redução não afeta a tipabilidade e não muda o tipo do termo afetado, logo o mesmo contexto inicial serve para inferir.

\emph{Prova: }

\begin{theorem}(Teorema da normalização forte)
    Todo termo legal $M$ é fortemente normalizável
\end{theorem}

Esse teorema garante que não existam termos que não são reduzíveis, ou seja, todo termo legal em $\lambda_{\rightarrow}$ possi uma forma normal e nem todo termo legal possui um ponto fixo. Isso faz com que o ST$\lambda$C não seja turing-completo.
Essa característica não é muito desejável na implementação de linguagens de programação, pois na vida real, é necessário implementar códigos que podem não terminar. Por esse motivo, é necessário formar extensões do cálculo para que ele funcione nesses casos. 

O fato do universo de funções legais possíveis ser reduzido bastante no ST$\lambda$C fez com que pesquisas em modelos partindo do Cálculo $\lambda$ não tipado fossem desenvolvidas. Esses modelos como trabalhados na subseção 1.2 possuem vantagens (e desvantagens) em relação à tipagem.

\subsection[Extensões ao STLC e as Teorias dos Tipos Simples]{Extensões ao ST$\lambda$C e as Teorias dos Tipos Simples}

Partindo do cálculo $\lambda$ não-tipado visto no capítulo anterior, sua tipagem natural é de fato a vista anteriormente usando somente tipos funcionais. Mas alguns comportamentos que os tipos deveriam ter acabam não sendo construidos ou sendo construidos de forma muito complicada e pouco natural. Alguns tipos adicionais são requeridos para construir uma teoria de tipos mais robusta.

A construção original da teoria dos tipos simples feita em \cite{church1940} já é, por si só, mais complexa que a teoria vista aqui. Dessa forma, esse seção se preocupa em extender o ST$\lambda$C visto até então para de fato a Teoria dos Tipos Simples.

Nessa seção serão introduzidos um tipo novo por vez, discutindo suas motivações, regras de inferência e exemplos de derivação. No final, eles serão reunidos para discutir a teoria dos tipos simples.


\subsubsection{Adendos sobre o tipo funcional}

Uma pergunta possível de se fazer é se a definição 3.1 pode ser reescrita tendo em mente as regras de inferência, e a resposta é sim. Para isso, é necessária a seguinte notação: seja $\alpha$ um tipo simples, a notação desse fato seria $\alpha \in \mathbb{T}$, agora pode-se usar a regra de$$\alpha \text{ Type}$$. Logo, é possível reformular a definição 3.1 da seguinte forma:

\begin{definition}
    Os tipos simples possuem as seguintes regras de derivação:
    \begin{enumerate}
        \item \AxiomC{}
              \RightLabel{para $\sigma \in \mathbb{V}$}
              \UnaryInfC{$\vdash \sigma \text{ Type} $}
              \DisplayProof
        \item 
        \AxiomC{$\vdash \sigma \text{ Type}$}
        \AxiomC{$\vdash \tau \text{ Type}$}
        \BinaryInfC{$\vdash \sigma \to \tau \text{ Type}$}
        \DisplayProof
    \end{enumerate}
\end{definition}

Outras formas de trabalhar com o conceito de tipos dessa forma serão introduzidos no próximo capítulo. Esse tipo de regra de inferência na teoria dos tipos simples serve para localizar de forma visual a formação dos tipos, por isso normalmente são chamadas de \emph{regras de formação}.

Uma outra forma de generalizar a construção feita anteriormente do tipo funcional é pensar as regras de inferência introduzidas anteriormente, a (\emph{abst}) e (\emph{appl}), como regras de introdução (\emph{intro}) e eliminação (\emph{elim}), respectivamente. Essas regras serão colocadas aqui:

\begin{center}
    \AxiomC{$\Gamma, x : \alpha \vdash M : \beta$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda x : \alpha . M : \alpha \to \beta$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash M : \alpha \to \beta$}
    \AxiomC{$\Gamma \vdash N : \alpha$}
    \LeftLabel{$\quad$($\to$-elim)}
    \BinaryInfC{$\Gamma \vdash MN : \beta$ }
    \DisplayProof
\end{center}


Outras duas regras de inferência importantes para a construção feita aqui são construidas em cima da $\beta$-redução e da $\eta$-redução. Para lembrar, a $\beta$-redução de um termo $(\lambda x . M)N$ é o termo $M[N/x]$ e a $\eta$-redução do termo $\lambda x . Mx$ é o termo $M$. Essas duas reduções podem ser escritas equacionalmente: seja $=$ uma relação de igualdade entre termos de um mesmo tipo, então  

\begin{center}
    \AxiomC{$\Gamma, x : \alpha \vdash M : \beta$}
    \AxiomC{$\Gamma \vdash N : \alpha$}
    \LeftLabel{$\beta$}
    \BinaryInfC{$\Gamma \vdash (\lambda x : \alpha . M)N = M[N/x] : \beta$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash M : \alpha \to \beta$}
    \LeftLabel{$\quad \eta$}
    \UnaryInfC{$\Gamma \vdash \lambda x : \alpha . Mx = M : \alpha \to \beta$}
    \DisplayProof
\end{center}


Nas exposições dos novos tipos nesse capítulo, os tipos serão introduzidos na ordem vista anteriormente sempre que possível: formação, introdução, eliminação, $\beta$-redução e $\eta$-redução.


\subsubsection{O tipo de produto e o tipo unitário ($\lambda 1_{\times}$)}

Uma primeira extensão do ST$\lambda$C é a teoria dos tipos simples possuindo os tipos funcionais, tipos de produto e o tipo unitário.

\emph{I. Tipo unitário}

O tipo unitário, também chamado de tipo vazio, é um tipo postulado, ou seja sua formação se comporta mais ou menos como na definição 3.8(1) vista anteriormente:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \mathbb{1} \text{ Type}$}
\end{prooftree}

Sua regra de introdução é a seguinte:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash () : \mathbb{1}$}
\end{prooftree}

O nome unitário é dado porque ele é somente habitado por um único termo denotado por $()$ ou por vezes $\langle \rangle$. Para postular que esse termo é único, é necessário ainda introduzir a seguinte regra:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \mathbb{1}$}
    \LeftLabel{$\eta$}
    \UnaryInfC{$\Gamma \vdash M = () : \mathbb{1}$}
\end{prooftree}

Sua regra de eliminação vai ser introduzida aqui da seguinte forma:

\begin{prooftree}
    \AxiomC{$ \vdash c : C$}
    \UnaryInfC{$ x : \mathbb{1} \vdash let () = x \text{ in } c : C$}
\end{prooftree}

Essa regra muda um pouco na teoria dos tipos dependentes mas isso será visto posteriormente.

A regra que falta é a da $\beta$-redução:

\begin{prooftree}
    \AxiomC{$ \vdash () : \mathbb{1}$}
    \LeftLabel{$\beta$}
    \UnaryInfC{$\vdash (let () = () \text{ in } c) = c : C$}
\end{prooftree}


\emph{II. Tipos de Produtos}

Os tipos de produtos são tipos que se comportam como pares ordenados. Sua notação de tipo é denotada pelo simbolo $\times$ como nos pares ordenados normalmente, sendo sua regra de formação:

\begin{prooftree}
    \AxiomC{$\vdash \sigma \text{ Type}$}
    \AxiomC{$\vdash \tau \text{ Type}$}
    \BinaryInfC{$\vdash \sigma \times \tau \text{ Type}$}
\end{prooftree}

Os elementos de um tipo $\sigma \times \tau$ são pares $\langle v, u\rangle$ formados por elementos $v : \sigma$ e $u : \tau$. Para eliminar esse tipo, é somente necessário pegar o primeiro elemento ou o segundo elemento do par e para isso são usados os operadores $\pi_1$ e $\pi_2$, respectivamente, chamados de \emph{projeções}.

Logo, as suas regras de introdução e eleminação são:

\begin{center}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \AxiomC{$\Gamma \vdash N : \tau$}
    \LeftLabel{($\times$-intro)}
    \BinaryInfC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$ }
    \DisplayProof

    \AxiomC{$\Gamma \vdash P : \sigma \times \tau$}
    \LeftLabel{$\quad$($\times$-elim-$1$)}
    \UnaryInfC{$\Gamma \vdash \pi_1 P : \sigma$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash P : \sigma \times \tau$}
    \LeftLabel{$\quad$($\times$-elim-$2$)}
    \UnaryInfC{$\Gamma \vdash \pi_2 P : \tau$ }
    \DisplayProof
\end{center}

As suas regras de $\beta$-redução sãs as seguintes:

\begin{center}
    \AxiomC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$}
    \LeftLabel{$\beta$}
    \UnaryInfC{$\Gamma \vdash \pi_1 \langle M, N \rangle = M : \sigma$ }
    \DisplayProof
    \AxiomC{$\Gamma \vdash \langle M, N \rangle : \sigma \times \tau$}
    \LeftLabel{$\quad\beta$}
    \UnaryInfC{$\Gamma \vdash \pi_2 \langle M, N \rangle = N : \tau$ }
    \DisplayProof
\end{center}

E a sua regra de $\eta$-redução é a seguinte:

\begin{prooftree}
    
    \AxiomC{$\Gamma \vdash t : \sigma \times \tau$}
    \LeftLabel{$\eta$}
    \UnaryInfC{$\Gamma \vdash \langle \pi_1 t, \pi_2 t \rangle = t : \sigma \times \tau$}
\end{prooftree}

As regras de substituição para o tipo de produtos são as seguintes:

$$(\pi_1 P)[L/v] \equiv \pi_1 (P[L/v])$$
$$(\pi_2 P)[L/v] \equiv \pi_2 (P[L/v])$$
$$\langle M, N \rangle [L/v] \equiv \langle M [L/v], N [L/v] \rangle$$


\emph{3. Exemplo}

Um exemplo básico do tipo de produto é a construção do seguinte tipo: $\sigma \times \tau \to \tau \times \sigma$. Ele significa basicamente que a operação de produto cartesiano é reflexiva e pode ser provado da seguinte forma:

\begin{prooftree}
    \AxiomC{$?$}
    \UnaryInfC{$\Gamma \vdash ? : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Usando a regra ($\to$-intro):

\begin{prooftree}
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash ? : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . ? : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Agora é necessário gerar um par onde o primeiro termo tem tipo $\tau$ e o segundo tem tipo $\sigma$.

\begin{prooftree}
    \AxiomC{$\Gamma, t : \sigma \times \tau \vdash \langle ? , ? \rangle : \tau \times \sigma$}
    \LeftLabel{($\times$-intro)}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash \langle ? , ? \rangle : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . \langle ? , ? \rangle : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Sabendo que o tipo de $\pi_1 t$ é $\sigma$ e o tipo de $\pi_2 t$ é $\tau$, sabe-se que $\langle \pi_2 t, \pi_1 t \rangle$ tem o tipo $\tau \times \sigma$ que é o tipo que se quer encontrar, logo:

\begin{prooftree}
    \AxiomC{$\Gamma, t : \sigma \times \tau \vdash \langle \pi_2 t ,\pi_1 t \rangle : \tau \times \sigma$}
    \LeftLabel{($\times$-intro)}
    \UnaryInfC{$\Gamma, t : \sigma \times \tau \vdash \langle \pi_2, \pi_1 t \rangle : \tau \times \sigma$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda t : \sigma \times \tau . \langle  \pi_2, \pi_1 t \rangle : \sigma \times \tau \to \tau \times \sigma$}
\end{prooftree}

Uma prova para o leitor é mostrar que $(\alpha \times \beta) \times \gamma \to \alpha \times (\beta \times \gamma)$ é habitado. 

Outro fato interessante que pode ser provado é o \emph{currying} que pode ser resumido no seguinte tipo: $((\alpha \times \beta) \to \gamma) \to (\alpha \to \beta \to \gamma)$. Isso mostra que caso a pessoa tenha uma função que pega um par e retorna um tipo, isso é o mesmo que uma função que pega cada elemento do par em um momento e retorna esse tipo.

A sua construção é feita da seguinte forma:

$\lambda f : ((\alpha \times \beta) \to \gamma) . \lambda x : \alpha . \lambda y : \beta . f\langle x, y \rangle$

\subsubsection{O tipo de produto disjunto e tipo vazio ($\lambda 1_{(\times, +)}$)}

\emph{I. O Tipo Vazio}

Enquanto o tipo unitário é caracterizado pela característica de só possuir um único termo, enquanto o tipo vazio é caracterizado de forma análoga por ser um tipo que não possui nenhum termo.

A sua regra de formação é a seguinte:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \emptyset \text{ Type}$}
\end{prooftree}

O tipo vazio, como seu próprio nome indica, não possui uma regra de introdução de termos.

\emph{II. O Tipo produto disjunto}

O tipo produto disjunto é uma formação na teoria dos tipos análoga à formação do produto disjunto na teoria dos conjuntos. Sua regra de formação é a seguinte:

\begin{prooftree}
    \AxiomC{$\vdash \sigma \text{ Type}$}
    \AxiomC{$\vdash \tau \text{ Type}$}
    \BinaryInfC{$\vdash \sigma + \tau \text{ Type}$}
\end{prooftree}

Sua regra de introdução, diferente do tipo de produto falado anteriormente, não depende da presença de dois termos, um para cada tipo no produto, mas somente de um dos dois termos:

\begin{center}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \LeftLabel{($+$-intro-1)}
    \UnaryInfC{$\Gamma \vdash \kappa M : \sigma + \tau$}
    \DisplayProof
    \AxiomC{$\Gamma \vdash N : \tau$}
    \LeftLabel{($+$-intro-2)}
    \UnaryInfC{$\Gamma \vdash \kappa' N : \sigma + \tau$}
    \DisplayProof
\end{center}

Normalmente o operador $\kappa$ é chamado de $inl$ enquanto o operador $\kappa'$ é chamado de $inr$ na teoria dos tipos dependentes, mas aqui está sendo usada a notação de \cite{jacobs1999}. $\kappa$ é denominado de \emph{coprojeção}

Sua regra de eliminação é a mais complexa introduzida aqui, sendo a seguinte:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash P : \sigma + \tau$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{($+$-elim)}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } P \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] : \rho$}
\end{prooftree}

A interpretação dessa regra é a seguinte: olhe para $P$, se $P$ está em $\sigma$ então faça $Q$ com $P$ sendo $x$, caso $P$ esteja em $\tau$, faça $R$ com $P$ como $y$.

Para o unpack, as regras de $\beta$-redução se seguem da interpretação da eliminação:

\begin{prooftree}
    \AxiomC{$\Gamma \vdash M : \sigma$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } \kappa M \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] = Q[M/x] : \rho$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash N : \tau$}
    \AxiomC{$\Gamma, x : \sigma \vdash Q : \rho$}
    \AxiomC{$\Gamma, y : \tau \vdash R : \rho$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash \text{unpack } \kappa' N \text{ as } [\kappa x \text{ in } Q, \kappa'y \text{ in } R] = R[N/y] : \rho$}
\end{prooftree}

A regra de $\eta$ redução é a seguinte:


\begin{prooftree}
    \AxiomC{$\Gamma \vdash P : \sigma + \tau$}
    \AxiomC{$\Gamma, z : \sigma + \tau \vdash R : \rho$}
    \LeftLabel{$\eta$}
    \BinaryInfC{$\Gamma \vdash \text{unpack } P \text{ as } [\kappa x \text{ in } R[(\kappa x)/z], \kappa'y \text{ in } R[(\kappa' y)/z]] = R[P/z] : \rho$}
\end{prooftree}

O operador unpack também pode ser chamado de \emph{match}, por ter essa noção de casar as coprojeções de $P$ para dois casos diferentes.

\emph{III. Exemplo}

Uma prova interessante é a que os coprodutos são distributivos em relação à produtos, ou seja $((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$

Para isso, é necessário construir a seguinte árvore de prova:

\begin{prooftree}
    
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma \vdash ? : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

Usando a abstração:

\begin{prooftree}
    
    \AxiomC{$?$}
    \LeftLabel{$?$}
    \UnaryInfC{$\Gamma, u : (\sigma \times \tau) + (\sigma \times \rho) \vdash ? : \sigma \times (\tau + \rho)$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda u : (\sigma \times \tau) + (\sigma \times \rho) . ? : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

Ao "abrir" $u$, tem-se duas possibilidades:

\begin{itemize}
    \item $u$ é do tipo $\sigma \times \tau$, ou seja $\pi_1 u = \sigma$ e $\pi_2 u = \tau$, com $pi_1 u$ tem-se a primeira parte do tipo objetivo, já $\tau + \rho$ é possível ser gerado por $\kappa (\pi_2 u)$
    \item $u$ é do tipo $\sigma \times \rho$, ou seja $\pi_1 u = \sigma$ e $\pi_2 u = \rho$, da mesma forma tem-se a primeira parte do tipo objetivo de cara, já $\tau + \rho$ é gerado por $\kappa' (\pi_2 u)$.
\end{itemize}

Logo o termo final é o seguinte:
$$ \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho)$$

Logo a árvore final é:


\begin{prooftree}
    \AxiomC{$\Gamma \vdash u : (\sigma \times \tau) + (\sigma \times \rho)$}
    \AxiomC{$\Gamma, x : (\sigma \times \tau)  \vdash  : \langle \pi_1 x, \kappa( \pi_2 x) \rangle : \sigma \times (\tau + \rho)$}
    \AxiomC{$\Gamma, y : (\sigma \times \rho) \vdash \langle \pi_1 y, \kappa'( \pi_2 y) \rangle : \sigma \times (\tau + \rho)$}
    \LeftLabel{($+$-elim)}
    \TrinaryInfC{$\Gamma, u : (\sigma \times \tau) + (\sigma \times \rho) \vdash \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho)$}
    \LeftLabel{($\to$-intro)}
    \UnaryInfC{$\Gamma \vdash \lambda u : (\sigma \times \tau) + (\sigma \times \rho) . \text{unpack } u \text{ as } [\kappa x \text{ in } \langle \pi_1 x, \kappa( \pi_2 x) \rangle, \kappa'y \text{ in } \langle \pi_1 y, \kappa'( \pi_2 y) \rangle] : \sigma \times (\tau + \rho) : ((\sigma \times \tau) + (\sigma \times \rho)) \to \sigma \times (\tau + \rho)$}
\end{prooftree}

O resto da dedução da árvore fica como exercício para o leitor.

\subsubsection{O Tipo dos Números Naturais}

Foi visto na parte do cálculo $\lambda$ não tipado a codificação dos números naturais utilizando o método da codificação de Church. Esse tipo de codificação é útil caso se queira trabalhar com uma versão reduzida da teoria dos tipos e possui propriedades interessantes que serão exploradas na parte do Sistema F no próximo capítulo. Porém, uma de suas desvantagens é que muitas vezes os cálculos podem demandar muito, principalmente se essa codificação for utilizada em linguagens de programação. Dessa forma, um jeito mais fácil de desenvolver os números naturais é postulando-os da mesma forma que foi feito anteriormente.

Primeiro, é necessário postular a existência de um tipo dos números naturais:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash \mathbb{N} \text{ Type}$}
\end{prooftree}

A sua regra de introdução segue os axiomas de Peano sobre o número $0$ e a função sucessor $succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$ que leva um número $n$ ao seu sucessor $n + 1$. Na forma de regras de inferência:

\begin{center}
    \AxiomC{}
    \UnaryInfC{$\vdash 0 : \mathbb{N}$}
    \DisplayProof
    \AxiomC{}
    \LeftLabel{$\qquad$}
    \UnaryInfC{$\vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    \DisplayProof
\end{center}

Essa forma de definir a função sucessor é encontrada em por exemplo \cite{rijke2022}. Uma outra forma de definir o sucessor é a vista em \cite{pfanning2009} como:


\begin{prooftree}
    \AxiomC{$\vdash n : \mathbb{N}$}
    \UnaryInfC{$\vdash S (n) : \mathbb{N}$}
\end{prooftree}

A regra de eliminação do tipo $\mathbb{N}$ é baseado no método da indução que diz o seguinte: Seja $\phi$ um predicado tal que

\begin{enumerate}[label=(\arabic*)]
    \item $\phi(0)$ é verdade, e
    \item para todo número natural $n$, se $\phi(n)$ é verdadeiro, então $\phi(S(n))$ também o é
\end{enumerate}

Logo $\phi(n)$ é verdadeiro para todo número natural $n$. 

Para a teoria dos tipos simples, o predicado $\phi$ se torna um tipo $P$ e sua regra de eliminação se torna:


\begin{prooftree}
    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{($\mathbb{N}$-elim)}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S) : \mathbb{N} \to P$}
\end{prooftree}

A interpretação dessa regra é a seguinte:

\begin{itemize}
    \item Premissa 1: Dado que de um termo $n : \mathbb{N}$ é possível derivar o tipo $P$
    \item Premissa 2: Dado que $P$ é válido para $0$, tendo como prova $p_0$
    \item Premissa 3: equivale à regra (2) para o predicado $\phi$ anterior
    \item Conclusão: o termo $ind_{\mathbb{N}}(p_0, p_S)$ é a função que pega as duas provas da indução e gera o tipo $P$.
\end{itemize}

Como sua regra de eliminação está relacionada ao conceito de indução, o tipo $\mathbb{N}$ é chamado de um \emph{tipo indutivo}. Não só $\mathbb{N}$ é um tipo, indutivo, mas também outros tipos como o tipo unitário e o tipo dos booleanos, que será visto posteriormente, podem ser vistos como tipos indutivos.

As regras de computação, para $\beta$-redução, são escritas uma para o caso base, $p_0$, e outra para o passo indutivo, $p_S$:

\begin{center}
    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S, 0_{\mathbb{N}}) = p_0 : P$}
    \DisplayProof


    \AxiomC{$\Gamma, n : \mathbb{N} \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : \mathbb{N} \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{\mathbb{N}}(p_0, p_S, succ_{\mathbb{N}}(n)) = p_S(n, ind_{\mathbb{N}}(p_0, p_S, n)) : P$}
    \DisplayProof
\end{center}

Exemplo:

\begin{definition}[Adição, \cite{rijke2022}]
    Definindo uma função $$add_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$$
    que satisfaça a especificação:
    $$add_{\mathbb{N}}(m, 0_{\mathbb{N}}) = m$$
    $$add_{\mathbb{N}}(m, succ_{\mathbb{N}}(n)) = succ_{\mathbb{N}}(add_{\mathbb{N}}(m, n))$$
    $add_{\mathbb{N}}(m, n)$ será denotado por $m + n$
\end{definition}

Para sua construção, é necessário usar a regra de eliminação para $P = \mathbb{N}$. Logo, as premissas se tornam:

$$m : \mathbb{N} \vdash \mathbb{N}$$
$$m: \mathbb{N} \vdash add-zero_{\mathbb{N}} (m) : \mathbb{N}$$
$$m: \mathbb{N} \vdash add-succ_{\mathbb{N}} (m) : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$$

e sua conclusão é:

$$m : \mathbb{N} \vdash add_{\mathbb{N}}(m) := ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$$

O termo $add-zero_{\mathbb{N}} (m)$ é o próprio $m$, já para a adição do sucessor, é necessário saber qual o comportamento da soma para o sucesso, que é a seguinte:

$$add_{\mathbb{N}}(m, succ_{\mathbb{N}}(n)) = succ_{\mathbb{N}}(add_{\mathbb{N}}(m, n))$$

Logo, $add-succ_{\mathbb{N}}(m)$ é o mesmo que o sucessor da adição:

$$add-succ_{\mathbb{N}}(m) := \lambda n . succ_{\mathbb{N}}$$

A árvore de derivação desse termo é o seeguinte:

\begin{prooftree}
    \AxiomC{$\vdash \mathbb{N} \to \mathbb{N}$}
    \AxiomC{$\vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{($\mathbb{N}$-intro)}
    \BinaryInfC{$n : \mathbb{N} \vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{(weak)}
    \UnaryInfC{$m : \mathbb{N}, n : \mathbb{N} \vdash succ_{\mathbb{N}} : \mathbb{N} \to \mathbb{N}$}
    % \LeftLabel{($\to$-intro)}
    \UnaryInfC{$m : \mathbb{N} \vdash \lambda n . succ_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
    \UnaryInfC{$m : \mathbb{N} \vdash add-succ_{\mathbb{N}}(m) := \lambda n . succ_{\mathbb{N}} : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
\end{prooftree}


A regra de inferência final se torna:

\begin{prooftree}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m : \mathbb{N} \vdash \mathbb{N} \text{ Type}$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m: \mathbb{N} \vdash add-zero_{\mathbb{N}} (m) := m : \mathbb{N}$}
    \AxiomC{$\vdots$}
    \UnaryInfC{$m: \mathbb{N} \vdash add-succ_{\mathbb{N}} (m) : \mathbb{N} \to (\mathbb{N} \to \mathbb{N})$}
    \TrinaryInfC{$m : \mathbb{N} \vdash ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$}
    \UnaryInfC{$m : \mathbb{N} \vdash add_{\mathbb{N}}(m) := ind_{\mathbb{N}}(add-zero_{\mathbb{N}} (m), add-succ_{\mathbb{N}} (m)) : \mathbb{N} \to \mathbb{N}$}
\end{prooftree}


\subsubsection{O Tipo dos Booleanos}

O tipo booleano é um tipo que possui dois elementos: um que corresponde ao valor verdadeiro na lógica proposicional e outro que corresponde ao valor falso.

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$\vdash Bool \text{ Type}$}
\end{prooftree}

Sua regra de introdução é:

\begin{center}
    \AxiomC{}
    \LeftLabel{($bool$-intro)}
    \UnaryInfC{$\vdash false : Bool$}
    \DisplayProof
    \AxiomC{}
    \LeftLabel{$\qquad$($bool$-intro)}
    \UnaryInfC{$\vdash true : Bool$}
    \DisplayProof
\end{center}

O tipo dos booleanos é um tipo indutivo, logo sua eliminação segue uma forma parecida à regra dos naturais:

\begin{prooftree}
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_1 : P$}
    \LeftLabel{($Bool$-elim)}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1) : Bool \to P$}
\end{prooftree}

Suas regras de $\beta$-redução são as seguintes:

\begin{center}
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : Bool \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1, false) = p_0 : P$}
    \DisplayProof

    \hfill
    \AxiomC{$\Gamma, b : Bool \vdash P \text{ Type}$}
    \AxiomC{$\Gamma \vdash p_0 : P$}
    \AxiomC{$\Gamma \vdash p_S : Bool \to P \to P$}
    \LeftLabel{$\beta$}
    \TrinaryInfC{$\Gamma \vdash ind_{Bool}(p_0, p_1, true) = p_1 : P$}
    \DisplayProof
\end{center}

Exemplo

Um exemplo é a função de negação, que pega $true$ e retorna $false$, e vice-versa. Essa função pode ser construida usando a regra da eliminação dos booleanos usando $P := Bool$:

\begin{prooftree}
    \AxiomC{$b : Bool \vdash Bool \text{ Type}$}
    \AxiomC{$b : Bool \vdash false : Bool$}
    \AxiomC{$b : Bool \vdash true : Bool$}
    \LeftLabel{($Bool$-elim)}
    \TrinaryInfC{$\vdash ind_{Bool}(true, false) : Bool \to Bool$}
\end{prooftree}

Pelas regras de $\beta$-redução é possível ver que essa construção está correta.

\subsubsection{O Sistema T de Gödel}

O \emph{Sistema T de Gödel} é uma teoria dos tipos baseada na chamada \emph{Interpretação da Dialectica} realizada por Gödel no seu artigo "Über eine bisher noch nicht benützte Erweiterung des finiten Standpunktes" (Sobre uma extensão do ponto de vista finitário ainda não utilizada) publicado na revista Dialectica em 1958 \cite{godel1980}.

Nesse artigo, Gödel procura uma nova forma de provar a consistência da teoria dos números, usando como objetos primários construções abstratas como provas, proposições, etc. O sistema desenvolvido por Gödel utiliza uma construção de tipos próxima à construção feita por Alonzo Church, mas com algumas diferenças. Gödel não cita o cálculo $\lambda$ em seu artigo mas cita a teoria dos números intuicionista de Heyting.

A primeira interpretação no cálculo $\lambda$ do sistema T de gödel foi realizada no artigo de W.W.Tait "Intensional Interpretations of Functionals of Finite type" (Interpretações intensionais de funcionais de tipo finito) de 1967 \cite{tait1967}.

Uma formulação mais contemporânea do Sistema T de Gödel é feita em \cite{girard1989} e será a usada aqui.

\begin{definition}[Tipos do Sistema T de Gödel, \cite{girard1989}]
    \hfill
    \begin{enumerate}
        \item Tipos atômicos $T_1, T_2, \dots, T_n$ são tipos
        \item Se $U$ e $V$ são tipos, então $U \times V$ e $U \to V$ são tipos
        \item O tipo $Int$ é o tipo dos números inteiros
        \item O tipo $Bool$ é o tipo dos booleanos
    \end{enumerate}
\end{definition}

Já os termos são definidos da seguinte forma:

\begin{definition}[Termos do Sistema T, \cite{girard1989}]
    \hfill
    \begin{enumerate}
        \item As variáveis $x_0^T, \dots, x_n^T, \dots$ são termos de tipo $T$
        \item Se $u$ e $v$ são termos de tipos $U$ e $V$, respectivamente, $\langle u, v \rangle$ é um termo de tipo $U \times V$
        \item Se $t$ é um termo de tipo $U \times V$, então $pi^1 t$ e $\pi^2 t$ são termos de tipo $U$ e $V$, respectivamente
        \item Se $v$ é um termo de tipo $V$ e $x_n^U$ é uma variável de tipo $U$, então $\lambda x^U_n . v$ é um termo de tipo $U \to V$
        \item Se $t$ e $u$ são termos de tipos $U \to V$ e $U$ respectivamente, então $tu$ é um termo do tipo $V$
        \item ($Int$-introdução)
        \begin{itemize}
            \item $O$ é uma constante de tipo $Int$
            \item se $t$ tem tipo $Int$, $St$ tem tipo $Int$
        \end{itemize}
        \item ($Int$-eliminação) se $u$, $v$ e $t$ possuem tipo $U$, $U \to (Int \to U)$ e $Int$, então $Ruvt$ tem tipo $U$
        \item ($Bool$-introdução) $T$ e $F$ são constantes de tipo $Bool$
        \item ($Bool$-eliminação) se $u$, $v$ e $t$ possuem tipo $U$, $U$ e $Bool$, então $Duvt$ tem tipo $U$
    \end{enumerate}
\end{definition}

As duas definições anteriores preservam a notação de Girard, mas salvo excessões essa notação não será mantida, por quebrar a continuidade da notação feita até então. 

O leitor que viu as extensões até então vai perceber que o Sistema T de Gödel é uma extensão da ST$\lambda$C que possui os tipos $\times, \mathbb{N}$ e $Bool$. A diferença é a nomeclatura ($Int$ no lugar de $\mathbb{N}$) e as regras de eliminação para os tipos indutivos, pois, pela interpretação de  \cite{girard1989}, $R$ é o operador de recursão e $D$ é interpretado como "se ... então ... senão".

\begin{definition}[Regras de Conversão, \cite{girard1989}]
    \hfill
    \begin{enumerate}
        \item $RuvO \to_{\beta} u$
        \item $Ruv(St) \to_{\beta} v(Ruvt)t$
        \item $DuvT \to_{\beta} u$
        \item $DuvF \to_{\beta} v$
    \end{enumerate}
\end{definition}



Exemplos de booleanos:

\begin{enumerate}
    \item $neg(u) = DFTu$
    \item $disj(u, v) = DTvu$
    \item $conj(u, v) = DvFu$
\end{enumerate}

Exemplos de inteiros:

\begin{enumerate}
    \item $add(x, y) = Rx(\lambda z^{Int} . \lambda z'^{Int} . Sz)y$
\end{enumerate}


\begin{theorem}[Teorema da Normalização Forte, \cite{girard1989}]
    No sistema T, todas as sequências de redução são finitas e resultam na mesma forma normal
\end{theorem}

\emph{Prova}: ver \cite{girard1989} seção 7.2


\subsubsection{A teoria simples de tipos de Church}

A teoria simples de tipos é a primeira formulação da teoria dos tipos simples em cima do cálculo $\lambda$ não tipado, realizado no artigo "A formulation of the simple theory of types" (Uma formulação da teoria simples de tipos) \cite{church1940}. Nessa teoria, Church construi um sistema axiomático de tipos em cima do cálculo $\lambda$. Nessa seção será feito um esforço de exposição dessa teoria como em seu primeiro artigo, apontando as suas diferenças em relação às formulações atuais da teoria dos tipos simples.

Para começar, a teoria simples de tipos de Church é um sistema axiomático, logo ele não faz uso de regras de inferência como foi feito anteriormente. 

As seguintes seções seguem a ordem do artigo original

\emph{I. Hierarquia de Tipos}

Nessa primeira parte, Church desenvolve a sintaxe dos \emph{simbolos de tipos}:

\begin{quote}
    "A classe de \emph{símbolos de tipos} é descrita pelas regras que $\iota$ e $o$ são cada um simbolos de tipos e que se $\alpha$ e $\beta$ são simbolos de tipos, então $(\alpha\beta)$ são simbolos de tipos." \cite[p. 56]{church1940}
\end{quote}

Letras gregas são usadas para variáveis de tipos (a exceção de $\iota$, $o$ e $\lambda$) e os tipos $\alpha\beta$ são associativos a esquerda.

A interpretação dos tipos é a seguinte:

\begin{quote}
    "Na interpretação da teoria, subíndices devem indicar que o tipo da variável é constante, $o$ sendo o tipo das proposições, $\iota$ o tipo dos individuos e $(\alpha\beta)$ sendo o tipo de funções com uma variável para os quais a faixa da variável independente compreende o tipo $\beta$ e a faixa da variável dependente é contida no tipo $\alpha$"
    \cite[p. 57]{church1940}
\end{quote}

Logo, é possível ver que $\alpha\beta$ corresponde ao tipo $\beta \to \alpha$ definido nas seções anteriores. $o$ não corresponde exatamente ao tipo dos booleanos, sendo normalmente tratado como o tipo $PROP$, enquanto $\iota$ representa variáveis individuais específicas.

Exemplo: O tipo $o\iota\iota$ é o mesmo que $\iota \to \iota \to o$.

\emph{II. Formulas bem formadas}

Uma vez definida a construção dos tipos, Church define a linguagem, da seguinte forma:

\begin{quote}
    "Os \emph{simbolos primitivos} são dados pela seguinte lista infinita:

    $$\lambda, (, ), N_{oo}, A_{ooo}, \Pi_{o(o\alpha)}, \iota_{\alpha(o\alpha)}, a_{\alpha}, b_{\alpha}, \dots, z_{\alpha}, \bar{a}_{\alpha}, \bar{b}_{\alpha}, \dots$$ "
    \cite[p. 57]{church1940}
\end{quote}


$N_{oo}, A_{ooo}, \Pi_{o(o\alpha)},$ e $\iota_{\alpha(o\alpha)}$ (Atualmente, $N : o \to o, A: o \to o \to o, \Pi : (\alpha \to o) \to o$ e $\iota : (\alpha \to o) \to \alpha$) são chamados de \emph{constantes} e o resto de \emph{variáveis}.

A definição de formulas bem formadas é a seguinte:

\begin{quote}
    "(1) uma formula consistindo de um símbolo único próprio é uma formula bem-formada e possui tipo indicado pelo subíndice; (2) se $x_{\beta}$ é uma variável com subíndice $\beta$ e $M_{\alpha}$ é uma formula bem-formada com tipo $\alpha$, então $(\lambda x_{\beta} M_{\alpha})$ é uma formula bem formada de tipo $\alpha\beta$; (3) se $F_{\alpha\beta}$ e $A_{\beta}$ são formulas bem-formadas de tipos $\alpha\beta$ e $\beta$, respectivamente, então $(F_{\alpha\beta}A_{\beta})$ é uma formula bem-formada de tipo $\alpha$"
    \cite[p. 57]{church1940}
\end{quote}

Essa definição constroi o início da $\beta$-redução, que será definida na pŕoxima parte.

Church usa a notação $\to$ no artigo da mesma forma que hoje em dia se usa $\equiv$ ou $:=$, como uma notação para "é uma abreviação de" e através disso ele constroi os operadores da lógica, a codificação de Church para os números naturais e os combinadores

Os operadores da lógica são os seguintes:

\begin{align*}
    & [\sim A_o ] \to N_{oo}A_o \\
    & [A_o \lor B_o] \to A_{ooo} A_o B_o \\
    & [A_o B_0] \to [\sim [[\sim A_o] \lor [\sim B_o]]] \\
    & [A_o \supset B_o] \to [[\sim A_o] \lor B_o] \\
    & [A_o \equiv B_o] \to [[A_o \supset B_o][B_o \supset A_o]] \\
    & [(x_{\alpha}A_o)] \to \Pi_{o(o\alpha)}(\lambda x_{\alpha} A_o) \\
    & [(\exists x_{\alpha} A_o)] \to [\sim [(x_{\alpha})[\sim A_o]]] \\
    & [(, x_{\alpha}A_o)] \to \iota_{\alpha(o\alpha)}(\lambda x_{\alpha} A_o) \\
\end{align*}

Interpretação de cada linha

\begin{itemize}
    \item $N : o \to o$ é um operador de negação, tal que $\neg A := NA : o$;
    \item $A : o \to o \to o$ é um operador de disjunção, tal que $A' \lor B' := AA'B' : o$
    \item A codificação do operador de conjunção é feito usando a lei de De Morgan, tal que $A \land B := \neg (\neg A \lor \neg B) : o$
    \item A codificação do operador de implicação é feito também em cima da disjunção $A \Rightarrow B := (\neg A) \lor B : o$
    \item A codificação da biimplicação é feito da forma normal, $A \Leftrightarrow B := (A \Rightarrow B) \land (B \Rightarrow A) : o$
    \item A codificação do quantificador universal é feito usando $\Pi : (\alpha \to o) \to o$, sendo $\forall (x : \alpha) A := \Pi (\lambda x : \alpha . A) : o$
    \item A codificação do quantificador existencial é feito a partir do quantificador universal $\exists (x : \alpha) A := \neg (\forall (x : \alpha) \neg A) : o$
    \item O último quantificador é um operador de seleção próximo ao axioma da escolha, que pega um termo de cada tipo, construido no Principia Mathematica
\end{itemize}

A relação de igualdade entre dois termos é construido dentro de $o$, usando $Q$:

\begin{align*}
    & Q_{o\alpha\alpha} \to \lambda x_{\alpha} \lambda y_{\alpha}[(f_{o\alpha})[f_{o\alpha}x_{\alpha} \supset f_{o\alpha}y_{\alpha}]] \\
    & [A_{\alpha} = B_{\alpha}] \to Q_{o\alpha\alpha}A_{\alpha}B_{\alpha} \\
    & [A_{\alpha} \neq  B_{\alpha}] \to [\sim(A_{\alpha} = B_{\alpha})] \\
\end{align*}

Interpretação de cada linha:

\begin{itemize}
    \item $Q : \alpha \to \alpha \to o$ é um termo que para dois termos de tipo $\alpha$ ele retorna a proposição que mapeia todas as funções que são válidas para ambos os termos
    \item $A = B := QAB : o$
    \item $A \neq B := \neg (A = B) : o$
\end{itemize}

A construção dos combinadores $\textbf{I}$ e $\textbf{K}$ são os mesmos:

\begin{align*}
    & I_{\alpha\alpha} \to \lambda x_{\alpha} x_{\alpha} \\
    & K_{\alpha\beta\alpha} \to \lambda x_{\alpha}\lambda y_{\beta} x_{\alpha} \\
\end{align*}

Uma notação adotada por Church é usar $\alpha'$ como $((\alpha\alpha)(\alpha\alpha))$, ou $(\alpha \to \alpha) \to \alpha \to \alpha$, $\alpha''$ como $((\alpha'\alpha')(\alpha'\alpha'))$, etc.

A codificação dos numerais é a, assim chamada codificação de Church:

\begin{align*}
    & 0_{\alpha'} \to \lambda f_{\alpha \alpha} \lambda x_{\alpha} x_{\alpha} \\
    & 1_{\alpha'} \to \lambda f_{\alpha \alpha} \lambda x_{\alpha} (f_{\alpha\alpha}x_{\alpha}) \\
    & 2_{\alpha'} \to \lambda f_{\alpha \alpha} \lambda x_{\alpha} (f_{\alpha\alpha}(f_{\alpha\alpha}x_{\alpha})) \\
    & 3_{\alpha'} \to \lambda f_{\alpha \alpha} \lambda x_{\alpha} (f_{\alpha\alpha}(f_{\alpha\alpha}(f_{\alpha\alpha}x_{\alpha}))) \\
    & \dots \\
    & S_{\alpha'\alpha'} \to \lambda n_{\alpha'} \lambda f_{\alpha \alpha} \lambda x_{\alpha} f_{\alpha\alpha}(n_{\alpha'}f_{\alpha\alpha}x_{\alpha}) \\
    & N_{o \alpha'} \to \lambda n_{\alpha '}[(f_{o \alpha'}) f_{o \alpha'} 0_{\alpha'} \supset [[(x_{\alpha'})[f_{o \alpha'} x_{\alpha'} \supset f_{o \alpha'}(S_{\alpha' \alpha} x_{\alpha'})]] \supset f_{o \alpha'}n_{\alpha'}]] \\
    & \omega_{\alpha'' \alpha' \alpha'} \to \lambda y_{\alpha'} \lambda z_{\alpha'} \lambda f_{\alpha'\alpha'} \lambda g_{\alpha'} \lambda h_{\alpha\alpha} \lambda x_{\alpha} (y_{\alpha'} (f_{\alpha'\alpha'} g_{\alpha'} h_{\alpha\alpha})(z_{\alpha'}(g_{\alpha'}h_{\alpha\alpha})x_{\alpha})) \\
    & \langle A_{\alpha'}, B_{\alpha'} \rangle \to \omega_{\alpha'' \alpha' \alpha'} A_{\alpha'} B_{\alpha'} \\
    & P_{\alpha'\alpha'''} \to \lambda n_{\alpha'''} (n_{\alpha'''} (\lambda p_{\alpha''} \langle S_{\alpha' \alpha'} (p_{\alpha''}(K_{\alpha'\alpha'\alpha'}I_{\alpha'}) 0_{\alpha'}), p_{\alpha''}(K_{\alpha'\alpha'\alpha'}I_{\alpha'}) 0_{\alpha'} \rangle) \langle 0_{\alpha'}, 0_{\alpha'} \rangle, (K_{\alpha'\alpha'\alpha'}0_{\alpha'})I_{\alpha'}) \\
    & T_{\alpha''\alpha'} \to \lambda x_{\alpha'} [(, x_{\alpha''})[(N_{o \alpha''}x_{\alpha''})[x_{\alpha''}S_{\alpha'\alpha'}0_{\alpha'} = x_{\alpha'}]]]  \\
    & P_{\alpha'\alpha'} \to \lambda x_{\alpha'} (P_{\alpha'\alpha'''}(T_{\alpha'''a''}(T_{\alpha''a'}x_{\alpha'}))) \\
\end{align*}

Interpretação

\begin{itemize}
    \item Os números são os mesmos introduzidos na exposição da codificação de church no capítulo anterior, a diferença é que eles agora possuem o tipo $\alpha'$, que é o mesmo que $(\alpha \to \alpha) \to \alpha \to \alpha$
    \item $S : \alpha' \to \alpha'$ é a função sucessor, vista também anteriormente
    \item $N : \alpha' \to o$ denota a proposição "é um número natural (de tipo $\alpha'$)" (é equivalênte ao principio da indução)
    \item $T : \alpha' \to \alpha''$ transforma um número de tipo $\alpha'$ para outro de tipo $\alpha''$
    \item $P : \alpha''' \to \alpha'$ é a função predecessor que pega um número de tipo $\alpha'''$ e retorna seu predecessor de tipo $\alpha'$
    \item $P : \alpha' \to \alpha'$ é a função predecessor de mesmo tipo.
\end{itemize}

 Um dos problemas de usar essa codificação na teoria dos tipos simples é que para cada tipo $\alpha$ existem números, $S$ e $N$, existem duas formas de burlar isso de formas diferentes: ou usando a teoria dos tipos polimórfica (Isso será introduzido na exposição do Sistema F) ou tendo formas de transformar um número de um tipo em um número de outro tipo. Essa segunda forma é o caminho de Church, mas essa forma depende do axioma da escolha e não é construtivista. 

\emph{III. Regras de Inferência}

As regras de inferência introduzidas nesse capítulo são as seguintes:

\begin{quote}
    "As regras de inferência (ou regras de procedimento) são as seis seguintes:
    \begin{enumerate}[label=\Roman*]
        \item Para substituir uma parte $M_{\alpha}$ de uma formula pelo resultado de substituir $y_{\beta}$ por $x_{\beta}$ por todo $M_{\alpha}$, dado que $x_{\beta}$ não é uma variável livre em $M_{\alpha}$ e $y_{\beta}$ não ocorre em $M_{\alpha}$.
        \item Para substituir qualquer parte $((\lambda_{\beta}M_{\alpha})N_{\beta})$ de uma formula com o resultado de substituir $N_{\beta}$ por $x_{\beta}$ por todo $M_{\alpha}$, dado que as variáveis ligadas de $M_{\alpha}$ são distintas tanto de $x_{\beta}$ e das variáveis livres de $N_{\beta}$
        \item Onde $A_{\alpha}$ é o resultado de substituir $N_{\beta}$ por $x_{\beta}$ através de $M_{\alpha}$, substituir qualquer parte $A_{\alpha}$ de uma formula por $((\lambda_{\beta}M_{\alpha})N_{\beta})$, dado que as variáveis ligadas de $M_{\alpha}$ são distintas tanto de $x_{\beta}$ quando das variáveis livres de $N_{\beta}$
        \item De $F_{o \alpha} x_{\alpha}$ para inferir $F_{o \alpha} A_{\alpha}$, dado que $x_{\alpha}$ não é uma variável livre de $F_{o \alpha}$
        \item De $A_o \supset B_o$ e $A_o$, inferir $B_o$
        \item De $F_{o \alpha} x_{\alpha}$ inferir $\Pi_{o(o\alpha)}F_{o \alpha}$ dado que $x_{\alpha}$ não é uma variável livre de $F_{o \alpha}$
        "
        \cite[pag. 60]{church1940}
    \end{enumerate}
\end{quote}

A regra I é equivalênte à $\alpha$-conversão, a II e a III correspondem a $\beta$-redução, IV corresponde a $\alpha$-conversão no tipo $o$, V é o modus ponens e VI é uma regra de introdução do quantificador universal

\emph{IV. Axiomas formais}

Os axiomas formas são as seguintes formulas:

\begin{enumerate}
    \item $p \lor p \supset p$
    \item $p \supset p \lor q$
    \item $p \lor q \supset q \lor p$
    \item $p \supset q \supset (r \lor p \supset r \lor q)$
    \item[$5^{\alpha}$] $\Pi_{o(o\alpha)}f_{o\alpha} \supset f_{o\alpha}x_{\alpha}$
    \item[$6^{\alpha}$] $(x_\alpha)[p \lor f_{o\alpha}x_{\alpha}] \supset p \lor \Pi_{o(o\alpha)}f_{o\alpha}$
    \item[7] $(\exists x_{\iota})(\exists y_{\iota}) x_{\iota} \neq y_{\iota} $
    \item[8] $N_{o \iota'}x_{\iota'} \supset N_{o \iota'}y_{\iota'} \supset (S_{\iota'\iota}x_{\iota'} = S_{\iota'\iota}y_{\iota'} \supset x_{\iota'} = y_{\iota'})$
    \item[$9^{\alpha}$] $f_{o \alpha} x_{\alpha} \supset (y_{\alpha}) [f_{o \alpha}y_{\alpha} \supset x_{\alpha} = y_{\alpha}] \supset f_{o \alpha} (\iota_{\alpha(o \alpha)} f_{o \alpha})$
    \item[$10^{\alpha\beta}$] $(x_{\beta})[f_{\alpha\beta} x_{\beta} = g_{\alpha\beta} x_{\beta}] \supset f_{\alpha\beta} = g_{\alpha\beta}$ 
    \item[$11^{\alpha}$] $f_{o \alpha} x_{\alpha} \supset f_{o \alpha} (\iota_{\alpha(o \alpha)} f_{o \alpha})$
\end{enumerate}

Interpretação:

Os axiomas 1-4 são suficientes para formar o cálculo proposicional e os axiomas 1-$6^{\alpha}$ formam o cálculo lógico funcional. Para construir a teoria dos números elementares é necessário adicionar a 1-$6^{\alpha}$ os axiomas $7, 8$ e $9^{\alpha}$. Para construir a análise real clássica é necessário usar $10^{\alpha\beta}$ (Axioma da extencionalidade) e $11^{\alpha}$ (Axioma da escolha)

\emph{V. Teorema da dedução}

VII - Teorema da dedução

- Regras de igualdade
- 21 equivale a regra eta


\emph{VI. Postulados de Peano para aritmética}

VIII - 

\emph{VII. Propriedades de T}

\emph{VIII. definição da recursão primitiva}


\subsection{Modelos da teoria dos tipos simples}

Uma forma de dar significado às funções do cálculo $\lambda$ foi utilizando modelos matemáticos. Como visto anteriormente nesse capítulo, outra forma, a que Church escolheu primeiramente, foi desenvolver uma teoria de tipos que podesse definir o domínio e contradomínio das funções do cálculo $\lambda$. Como visto, os modelos desenvolvidos para o cálculo $\lambda$ não tipado ganham força com o modelo de Scott $D_{\infty}$ que é construido em cima da teoria dos domínios e de CPOs.

Um problema que surge tendo tomado o ST$\lambda$C como a extensão que dava significado ao cálculo $\lambda$ é que ele da significado \emph{interno} ao cálculo, mas não possui força para desenvolver seu significado \emph{externo}. Ou seja, é possível construir a matemática dentro da teoria dos tipos simples, mas não é possível definir a teoria dos tipos simples dentro dela mesma. Para isso, diversos modelos \emph{semânticos} (ou seja, externos) foram construidos, alguns usando a Teoria das Categorias, como será visto na Parte III dessas notas, e outros usando intuições vindas dos modelos da teoria dos domínios de Scott.

O modelo definido nessa subseção será um apontado por \cite{girard1989} que utiliza uma estrutura chamada de \emph{espaços de coerência} (Coherence spaces, em inglês) ou \emph{espaços coerêntes} (espace cohérent ou coherent space) para tratar dos tipos.

\subsubsection{Espaços de Coerência}

Primeiro, é necessário definir esses espaços de coerência:

\begin{definition}[Espaços de Coerência, \cite{girard1989}]
    Um \emph{espaço de coerência} $\mathcal{A}$ é um conjunto que satisfaz:
    \begin{itemize}
        \item (Fechamento abaixo) se $a \in \mathcal{A}$ e $a' \subset a$ então $a' \in \mathcal{A}$
        \item (Completude binária) se $M \subset \mathcal{A}$ e para todo $a_1, a_2 \in M$, com $a_1 \cup a_2 \in \mathcal{A}$, então $\bigcup M \in \mathcal{A}$
    \end{itemize}
\end{definition}

Em particular, tem-se que o conjunto vazio está em $\mathcal{A}$, $\varnothing  \in \mathcal{A}$

Espaços de coerência podem ser considerados \emph{algebricamente} como "domínios".

Exemplos:

\begin{itemize}
    \item O espaço de coerência $\mathcal{B}ool$ na forma:
    \[\begin{tikzcd}
	{\{t\}} && {\{f\}} \\
	& \varnothing
	\arrow[no head, from=1-1, to=2-2]
	\arrow[no head, from=1-3, to=2-2]
\end{tikzcd}\]
    \item o espaço de coerência $\mathcal{I}nt$ na forma:
\[\begin{tikzcd}
	{\{0\}} & {\{1\}} & {\{2\}} & \dots \\
	\varnothing
	\arrow[no head, from=1-1, to=2-1]
	\arrow[no head, from=1-2, to=2-1]
	\arrow[no head, from=1-3, to=2-1]
\end{tikzcd}\]
\end{itemize}

\begin{definition}[\cite{girard1989}]
    Seja $|\mathcal{A}| \equiv \bigcup \mathcal{A} = \{\alpha : \{\alpha\} \in \mathcal{A}\}$. Os elementos de $|\mathcal{A}|$ são chamados de \emph{tokens} e é a \emph{relação de coerência modulo } $\mathcal{A}$ entre tokens é definida como:
    $$\alpha \stackrel{\frown}{\smile} \alpha' \quad \text{ iff } \quad \{\alpha, \alpha'\} \in \mathcal{A} $$
\end{definition}

Essa relação é reflexiva e simétrica, então $| \mathcal{A} |$ equipada com $\stackrel{\frown}{\smile}$ é um grafo, chamado de \emph{teia} de $|\mathcal{A}|$.

De uma teia é possível recuperar um espaço de coerência usando:

$$a \in \mathcal{A} \Leftrightarrow a \subset |\mathcal{A}| \land \forall \alpha_1, \alpha_2 \in a (\alpha_1 \stackrel{\frown}{\smile} \alpha_2 (mod \mathcal{A}))$$

Logo, um ponto $a$ de $\mathcal{A}$ forma um subgrafo completo, também chamado de um \emph{clique}.

Na interpretação de modelo dos espaços de coerência, um tipo é equivalente a um espaço de coerência $\mathcal{A}$ e um termo desse tipo é um ponto em $\mathcal{A}$.

Para trabalhar com pontos de forma eficiente, é necessário introduzir uma noção de aproximação:

\begin{definition}[Aproximante, \cite{girard1989}]
    Um \emph{aproximante} $a \in \mathcal{A}$ é qualquer subconjunto $a'$ de $a$. Existem suficientes aproximantes finitos, ou seja:
    \begin{itemize}
        \item $a$ é a união do conjunto de seus aproximantes finitos
        \item O conjunto $I$ de aproximantes finitos é \emph{direcionado}, ou seja:
        \begin{enumerate}
            \item $I$ não é vazio ($\varnothing \in I$)
            \item Se $a', a'' \in I$, é possível encontrar $a \in I$ tal que $a', a'' \subset a$ (simplesmente $a = a' \cup a''$)
        \end{enumerate}
    \end{itemize}
\end{definition}

\subsubsection{Funções Estáveis}

Tendo definido o que são espaços de coerência, é importante definir como relacionar os espaços de coerência entre si:

\begin{definition}[Função Estável, \cite{girard1989}]
    Dados dois espaços de coerência $\mathcal{A}$ e $\mathcal{B}$, uma função $F : \mathcal{A} \to \mathcal{B}$ é dita \emph{estável} se:
    \begin{enumerate}
        \item $a' \subset a \in \mathcal{A} \Rightarrow F(a') \subset F(a)$
        \item (União direta) $F(\bigcup_{i \in I}^{\uparrow} a_i) = \bigcup_{i \in I}^{\uparrow} F(a_i)$
        \item (\textbf{St}) $a_1 \cup a_2 \in \mathcal{A} \Rightarrow F(a_1 \cap  a_2) = F(a_1) \cap F(a_2)$
    \end{enumerate}
\end{definition}

A primeira condição diz que $F$ preserva aproximações. Já a segunda condição mostra que $F$ é contínua, ou seja $$F(a) = \bigcup^{\uparrow} \{ F(a_o) : a_o \subset a, a_o \text{ finite} \}$$. A terceira condição é análoga à condição de estabilidade de Berry. 

Essa definição se torna mais clara sendo tomada do ponto de vista categorial, onde $\mathcal{A}$ e $\mathcal{B}$ são categorias, pois $F$ se torna um funtor que preserva limites diretos (união direta) e pullbacks (St).

Exemplos:

Algumas funções estáveis $F$ de $Int$ para $Int$


\begin{itemize}
    \item Função constante: se $F(\varnothing) = \{ n \}$, então $F(a) = \{ n \}$ para todo $a \in Int$
    \item Se $F(\varnothing) = \varnothing$, então considere a função parcial $f$ definida exatamente nos inteiros $n$ tais que $F(\{ n \}) \neq \varnothing$, nesse caso $F(\{ n \}) = \{ f(n) \}$
\end{itemize}

Essas duas funções são importantes pois:

\begin{itemize}
    \item No primeiro caso, tira-se as constantes $\dot{n} (a) = \{n\}$. Já no segundo
    \item No segundo caso, tira-se as funções $\tilde{f}(\varnothing) = \varnothing$, $\tilde{f}(\{m\}) = \{n\}$
\end{itemize}

É possível construir funções $F_n : Bool \to Bool \to Bool$ que se comportam como a disjunção, no caso $F_n(\{\alpha\}, \{\beta\}) = \{\alpha \lor \beta\}$ para cada combinação de verdadeiro ou falso de $\alpha$ e $\beta$.

$\{\alpha\}$ e $\{\beta\}$ podem possuir três valores: $\{t\}, \{f\}$ ou $\varnothing$, logo existem nove possibilidades:

\begin{itemize}
    \item Os valores que se espera pela definição (onde nenhum dos dois é vazio) são:
    \begin{enumerate}
        \item $F_1(\{t\}, \{t\}) = F_1(\{t\}, \{f\})  = F_1(\{f\}, \{t\})  = \{t\}$ 
        \item $F_1(\{f\}, \{f\}) = \{ f \}$ 
    \end{enumerate}
    \item Para $F_1(\{t\}, \varnothing)$, $F_1(\{t\}, \varnothing) = \{t\}$ ou $F_1(\{t\}, \varnothing) = \varnothing$ é indiferente
    \item $F_1(\{f\}, \varnothing) = F_1(\varnothing, \{f\}) = \varnothing$, pois $F_1(\{f\}, \varnothing) \subset F_1(\{f\}, \{t\}) = \{t\}$ e $F_1(\varnothing, \{f\}) \subset F_1(\{t\}, \{f\}) = \{t\}$
    \item $F_1 (\varnothing, \varnothing) = \varnothing$ 
\end{itemize}

Outra solução seria considerar $F_2(a, b) = F_1(b, a)$

A primeira solução pode ser enxugada da seguinte forma:

\begin{itemize}
    \item $F_1(\{t\}, \{t\}) = F_1(\{t\}, \{f\})  = F_1(\{f\}, \{t\})  = \{t\}$ 
    \item $F_1(\{f\}, \{f\}) = \{ f \}$ 
    \item $\varnothing$ caso contrário
\end{itemize}

\subsubsection{Produto entre Espaços de coerência}

Para definir a semântica do tipo produto, é necessário definir uma forma de relacionar dois espaços de coerência.

Para isso, é necessário primeiro generalizar a definição de função estável para funções com dois espaços de coerênia como domínio:

\begin{definition}
    Uma função de dois argumentos, mapeando $\mathcal{A}$ e $\mathcal{B}$ para $\mathcal{C}$ é \emph{estável} quando:
    \begin{enumerate}
        \item Se $a' \subset a \in \mathcal{A}$ e $b' \subset b \in \mathcal{B}$, então $F(a', b') \subset F(a, b)$
        \item $F(\bigcup_{i \in I}^{\uparrow} a_i, \bigcup_{j \in J}^{\uparrow} b_j) = \bigcup_{(i, j) \in I \times J}^{\uparrow} F(a_i, b_j)$
        \item se $a_1 \cup a_2 \in \mathcal{A}$ e $b_1 \cup b_2 \in \mathcal{B}$, então $F(a_1 \cap a_2, b_1 \cap b_2) = F(a_1, b_1) \cap F(a_2, b_2)$
    \end{enumerate}
\end{definition}

Também é possível generalizar essa definição para funções que recebem $n$ argumentos (fica como exercício para o leitor). A terceira condição mostra que para que $F$ seja estável em dois argumentos, $F$ em cada argumento precisa ser estável por si só. Para evitar essa generalização, é interessante definir \emph{produtos (diretos)} de espaços de coerência, denotados $\mathcal{A} \& \mathcal{B}$:

\begin{definition}[Produto de dois espaços de coerência, \cite{girard1989}]
    Se $\mathcal{A}$ e $\mathcal{B}$ são dois espaços de coerênica, então o produto deles $\mathcal{A} \& \mathcal{B}$ é dado por:  
    $$| \mathcal{A} \& \mathcal{B} | = |\mathcal{A}| + |\mathcal{B}| = \{1\} \times |\mathcal{A}| \cup \{2\} \times |\mathcal{B}|$$

    Satisfazendo:
    \begin{align*}
        (1, \alpha) & \stackrel{\frown}{\smile} (1, \alpha') \quad (\text{mod } \mathcal{A} \& \mathcal{B}) \quad \text{iff } \alpha \stackrel{\frown}{\smile} \alpha' (\text{mod } \mathcal{A}) \\
        (2, \beta) & \stackrel{\frown}{\smile} (2, \beta') \quad (\text{mod } \mathcal{A} \& \mathcal{B}) \quad \text{iff } \beta \stackrel{\frown}{\smile} \beta' (\text{mod } \mathcal{B}) \\
        (1, \alpha) & \stackrel{\frown}{\smile} (2, \beta) \quad (\text{mod } \mathcal{A} \& \mathcal{B}) \quad \text{para todo } \alpha \in |\mathcal{A}| \text{ e }  \beta \in |\mathcal{B}|  \\
    \end{align*}
\end{definition}

Os pontos de $\mathcal{A} \& \mathcal{B}$ podem ser escritos unicamente como $\{1\} \times a \cup \{2\} \times b$ com $a \in \mathcal{A}$ e $b \in \mathcal{B}$

Dada uma função $F$ de $\mathcal{A}$ e $\mathcal{B}$ para $\mathcal{C}$, é possível definir uma função $G$ de $\mathcal{A} \& \mathcal{B}$ para $\mathcal{C}$ como:

$$G(\{1\} \times a \cup \{2\} \times b) = F(a, b)$$

\subsubsection{Espaço Funcional}

Na perspectiva de tipos como espaços de coerência, o produto de espaços de coerência é equivalente ao tipo produto. Para definir o tipo funcional $A \to B$, seria necessario desenvolver um espaço de coerência que descreva o conjunto de funções estáveis $\mathcal{A} \to \mathcal{B}$. Para isso, é necessário definir o \emph{traço} entre funções estáveis.

\begin{lemma}[\cite{girard1989}]
    Seja $F$ uma função estável de $\mathcal{A}$ para $\mathcal{B}$ e sejam $a \in \mathcal{A}$ e $\beta \in F(a)$, então:
    \begin{itemize}
        \item é possível encontrar $a_0 \subset a$ tal que $\beta \in F(a_0)$
        \item se $a_0$ é escolhido como o mínimo da inclusão entre as soluções de (i), então $a_0$ é o \emph{menor} e é, particularmente, \emph{único}.
    \end{itemize}
\end{lemma}

\emph{Prova}:
\begin{itemize}
    \item Seja $a = \bigcup^{\uparrow}_{i \in I} a_i$, onde os $a_i$ são subconjuntos finitos de $a$. Então $F(a) = \bigcup^{\uparrow}_{i \in I} F(a_i)$, e se $\beta \in F(a)$, $\beta \in F(a_{i_0})$ para algum $i_0 \in I$
    \item Seja $a_0$ mínimo e seja $a' \subset a$ tal que $\beta \in F(a')$. Então $(a_0 \cup a') \subset a \in \mathcal{A}$, então $a_0 \cup a' \in \mathcal{A}$ e $\beta \in F(a_0) \cap F(a') = F(a_0 \cap a')$. Como $a_0$ é mínimo, isso faz com que $a_0 \subset a_0 \cup a'$, então $a_0 \subset a'$ e $a_0$ é de fato o menor. $\qed$
\end{itemize}

\begin{definition}[Traço, \cite{girard1989}]
    O \emph{traço} $\mathcal{T}r(F)$ é o conjunto de pares $(a_0, \beta)$ tal que:
    \begin{itemize}
        \item $a_0$ é um ponto finito de $\mathcal{A}$ e $\beta \in |\mathcal{B}|$
        \item $\beta \in F(a_0)$
        \item se $a' \subset a_0$ e $\beta \in F(a')$, então $a' = a_0$
    \end{itemize}
\end{definition}

$\mathcal{T}r(F)$ determina $F$ unicamente pela formula:

$$(\text{App}) \qquad F(a) := \{\beta | \exists a_0 \subset a (a_0, \beta) \in \mathcal{T}r(F)\}$$

\begin{proposition}[\cite{girard1989}]
    Enquanto $F$ varia entre as funções estáveis de $\mathcal{A}$ a $\mathcal{B}$, seus traços dão pntos em um espaço de coerência, escrito $\mathcal{A} \to \mathcal{B}$
\end{proposition}

\emph{Prova}: Seja o espaço de coerência $\mathcal{C}$ dado por $|\mathcal{C}| = \mathcal{A}_{fin} \times |\mathcal{B}|$ ($\mathcal{A}_{fin}$ é o conjunto de pontos finitos de $\mathcal{A}$) onde $(a_1, \beta_1) \stackrel{\frown}{\smile} (a_2, \beta_2) \quad (\text{mod } \mathcal{C})$ se:
\begin{itemize}
    \item $a_1 \cup a_2 \in \mathcal{A} \Rightarrow \beta_1 \stackrel{\frown}{\smile} \beta_2 (\text{mod } \mathcal{B})$
    \item $a_1 \cup a_2 \in \mathcal{A} \land a_1 \neq a_2 \Rightarrow \beta_1 \neq \beta_2 (\text{mod } \mathcal{B})$
\end{itemize}

Se $F$ é estável, então $\mathcal{T}r(F)$ é um subconjunto de $|\mathcal{C}|$ por construção. É necessário verificar o modulo de coerência em $\mathcal{C}$ de $(a_1, \beta_1)$ e $(a_2, \beta_2) \in \mathcal{T}r(F)$:
\begin{itemize}
    \item Se $a_1 \cup a_2 \in \mathcal{A}$, então $\{\beta_1, \beta_2\} \subset F(a_1 \cup a_2)$ então $\beta_1 \stackrel{\frown}{\smile} \beta_2 (\text{mod } \mathcal{B})$
    \item Se $\beta_1 = \beta_2$ e $a_1 \cup a_2 \in \mathcal{A}$, então o lema aplicado a $\beta_1 \in F(a_1 \cup a_2)$ dá que $a_1 = a_2$
\end{itemize}

Por outro lado, seja $f$ um ponto de $\mathcal{C}$. A função entre $\mathcal{A}$ e $\mathcal{B}$ é definida pela formula:
$$(\text{App}) \qquad F(a) := \{\beta | \exists a_0 \subset a (a_0, \beta) \in f\}$$

Dessa forma:
\begin{itemize}
    \item $F$ é monótona
    \item Se $a = \bigcup^{\uparrow}_{i \in I} a_i$, então $F(a) = \bigcup^{\uparrow}_{i \in I} F(a_i)$ por monotonicidade. Por outro lado, se $\beta \in F(a)$, então existe um $a' \subset a$ finito tal que $\beta \in F(a')$, mas como $a' \subset \bigcup^{\uparrow}_{i \in I} a_i$, tem-se que $a' \subset a_k$ para algum $k$, então $\beta \in F(a_k)$ e a inclusão contrária é estabelecida
    \item Se $a_1 \cup a_2 \in \mathcal{A}$, então $F(a_1 \cap a_2) \subset F(a_1) \cap F(a_2)$ por monotonicidade. De forma contrária, se $\beta \in F(a_1) \cap F(a_2)$, então $(a_1', \beta), (a_2', \beta) \in f$ para alguns $a_1' \subset a_1$ e $a_2' \subset a_2$ apropriados. Mas $(a_1', \beta)$ e $(a_2', \beta)$ são coerentes e $a_1' \cup a_2' \subset a_1 \cup a_2 \in \mathcal{A}$, então $a'_1 = a'_2$, com $a'_1 \subset a_1 \cap a_2$ e $\beta \in F(a_1 \cap a_2)$
    \item $F(a)$, para $a \in \mathcal{A}$, é um subconjunto de $|\mathcal{B}|$ e é necessário mostrar sua coerência. Agora, sejam $\beta', \beta'' \in F(a)$, isso significa que $(a', \beta'), (a'', \beta'') \in f$ para $a', a'' \subset a$ apropriados. Mas então $a' \subset a'' \subset a \in \mathcal{A}$, então $(a', \beta')$ e $(a'', \beta'')$ são coerentes, $\beta' \stackrel{\frown}{\smile} \beta'' (\text{mod } \mathcal{B})$ $\qed$
\end{itemize}

Sendo $\mathcal{A} \to \mathcal{B}$ um espaço de coerência, ele é naturalmente ordenado por inclusão, pela seguinte relação de ordem:

$$F \leq_B G \qquad \text{sse} \qquad  \mathcal{T}r(F) \subset \mathcal{T}r(G)$$

\begin{proposition}
    A \emph{ordem de Berry} $\leq_B$ é dada por:

    $$F \leq_B G \qquad \text{sse} \qquad  \forall a, a' \in \mathcal{A} (a' \subset a \Rightarrow F(a') = F(a) \cap G(a'))$$
\end{proposition}

\emph{Prova}: Se $F \leq_B G$, então $F(a) \subset G(a)$ para todo $a$. Seja $(a, \beta) \in \mathcal{T}r(F)$, então $\beta \in F(a) \subset G(a)$. É necessário provar que $(a, \beta) \in \mathcal{T}r(G)$. Seja $a' \subset a$ tal que $\beta \in G(a')$, então $\beta \in F(a) \cap G(a') = F(a')$, que faz com que $a' = a$

Por outro lado, se $\mathcal{T}r(F) \subset \mathcal{T}r(G)$, é fácil ver que $F(a) \subset G(a)$ para todo $a$. De forma particular se $a' \subset a$, então $F(a') \subset F(a) \cap G(a')$. Agora se $\beta \in F(a) \cap G(a')$, é possível encontrar $a_0 \subset a$ e $a'_0 \subset a_0$ tais que:

$$(a_0, \beta) \in \mathcal{T}r(F)$$

e

$$(a'_0, \beta) \in \mathcal{T}r(G)$$

Então $(a_0, \beta)$ e $(a'_0, \beta)$ são coerentes, e como $a_0 \cup a_0' \subset a \in \mathcal{A}$, tem-se que $a_0 = a_0'$ e $\beta \in F(a_0') = F(a_0) \subset F(a')$ $\qed$


\subsubsection{A semântica do Tipo Soma}

\subsubsection{linearização}

\subsubsection{A semântica linearizada do tipo soma}

\subsubsection{A semântica do tipo unitário e Produtos Tensoriais}

\subsubsection{A semântica denotacional da teoria dos tipos simples}






\end{document}